<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="588728944ca294baca2932f2aae0887dfd3ec4be" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30351681" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="FileSystem" /> 模块包含用于执行文件、目录或文件夹以及系统操作的过程。 与使用 <see langword="My" /> 模块相比，<see langword="FileSystem" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此模块支持的 Visual Basic 语言关键字和访问文件和文件夹的运行时库成员。  
  
   
  
## Examples  
 此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必须的。 一个 <see langword="String" /> 表达式，用于标识哪个目录或文件夹将成为新的默认目录或文件夹。 <c>Path</c> 可以包含驱动器。 如果未指定驱动器，则 <see langword="ChDir" /> 更改当前驱动器上的默认目录或文件夹。</param>
        <summary>更改当前目录或文件夹。 与 <see langword="My" /> 函数相比，<see langword="ChDir" /> 功能在文件 I/O 操作方面可提供更高的效率和更好的性能。 有关详细信息，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`函数更改默认的目录，但不是在默认驱动器。 例如，如果默认驱动器 C，以下语句会更改驱动器 D 上的默认目录，但 C 保留默认驱动器：  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 你可以相对目录更改为通过键入两个句点，如下所示：  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`函数需要非托管的代码的权限，这可能会影响在部分信任情况下其执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和。  
  
   
  
## Examples  
 此示例使用`ChDir`函数来更改当前目录或文件夹。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 为空。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>更改当前驱动器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必须的。 指定现有驱动器的字符串表达式。 如果提供一个零长度字符串 ("")，则当前驱动器不会更改。 如果 <c>Drive</c> 参数为多字符字符串，<see langword="ChDrive" /> 将仅使用第一个字母。</param>
        <summary>更改当前驱动器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函数需要非托管代码的权限，这可能会影响在部分信任情况下其执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用`ChDrive`函数来更改当前驱动器。 如果驱动器不存在，则函数将引发异常。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必须的。 指定现有驱动器的字符串表达式。 如果提供一个零长度字符串 ("")，则当前驱动器不会更改。 如果 <c>Drive</c> 参数为多字符字符串，<see langword="ChDrive" /> 将仅使用第一个字母。</param>
        <summary>更改当前驱动器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函数需要非托管代码的权限，这可能会影响在部分信任情况下其执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用`ChDrive`函数来更改当前驱动器。 如果驱动器不存在，则函数将引发异常。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示当前路径的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`CurDir`函数以返回当前路径。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">可选。 指定现有驱动器的 <see langword="Char" /> 表达式。 如果未指定驱动器或 <c>Drive</c> 是零长度字符串 ("")，则 <see langword="CurDir" /> 返回当前驱动器的路径。</param>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示当前路径的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`CurDir`函数以返回当前路径。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>一个字符串，表示与指定模式或文件特性匹配的文件、目录或文件夹的名称，或者表示驱动器卷标。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 `VbVolume` 返回而不是特定文件名的驱动器的卷标签。  
  
 必须提供`PathName`第一次调用`Dir`函数。 若要检索的下一项，你可以后续调用`Dir`不带参数的函数。  
  
> [!IMPORTANT]
>  若要正确运行，`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>和<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|默认。 指定无特性文件。|  
|`ReadOnly`|`vbReadOnly`|指定只读文件，以及带属性的文件。|  
|`Hidden`|`vbHidden`|指定隐藏的文件，以及带属性的文件。|  
|`System`|`vbSystem`|指定系统文件，以及带属性的文件。|  
|`Volume`|`vbVolume`|指定卷标签;如果指定其他任何属性，则`vbVolume`将被忽略。|  
|`Directory`|`vbDirectory`|指定目录或文件夹，以及带属性的文件。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举由 Visual Basic 语言指定，并且可以使用而非实际值在代码中的任意位置。  
  
   
  
## Examples  
 此示例使用`Dir`函数来检查某些文件和目录是否存在。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">可选。 <see langword="String" /> 表达式，用于指定文件名、目录或文件夹名或者驱动器卷标。 如果未找到 <c>PathName</c>，则返回一个零长度字符串 (<see langword="&quot;&quot;" />)。</param>
        <param name="Attributes">可选。 其值指定文件特性的枚举或数值表达式。 如果省略，则 <see langword="Dir" /> 将返回与 <c>PathName</c> 匹配但不具有任何特性的文件。</param>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>一个字符串，表示与指定模式或文件特性匹配的文件、目录或文件夹的名称，或者表示驱动器卷标。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 `VbVolume` 返回而不是特定文件名的驱动器的卷标签。  
  
 必须提供`PathName`第一次调用`Dir`函数。 若要检索的下一项，你可以后续调用`Dir`不带任何参数的函数。  
  
> [!IMPORTANT]
>  若要正确运行，`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>和<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|默认。 指定无特性的文件。|  
|`ReadOnly`|`vbReadOnly`|指定只读文件，除了不具任何属性的文件。|  
|`Hidden`|`vbHidden`|指定隐藏的文件，除了不具任何属性的文件。|  
|`System`|`vbSystem`|指定系统文件，除了不具任何属性的文件。|  
|`Volume`|`vbVolume`|指定卷标签;如果指定其他任何属性，则`vbVolume`将被忽略。|  
|`Directory`|`vbDirectory`|指定目录或文件夹，以及不具任何属性的文件。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举由 Visual Basic 语言指定，并且可以使用的实际值替换代码中的任意位置。  
  
   
  
## Examples  
 此示例使用`Dir`函数来检查某些文件和目录是否存在。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 一个包含任何有效文件号的 <see langword="Integer" />。</param>
        <summary>当达到为进行 <see langword="True" /> 或顺序 <see langword="Random" /> 而打开的文件的结尾时，此方法返回布尔值 <see langword="Input" />。</summary>
        <returns>当达到为进行 <see langword="True" /> 或顺序 <see langword="Random" /> 而打开的文件的结尾时，此方法返回布尔值 <see langword="Input" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`EOF`以避免通过尝试获取输入文件的末尾而产生的错误。  
  
 `EOF`函数返回`False`之前已到达文件末尾。 打开以进行文件与`Random`或`Binary`访问，`EOF`返回`False`直到最后一个执行`FileGet`函数不能读取完整记录。  
  
 打开以进行文件与`Binary`访问，请尝试通过文件使用读取`Input`函数直到`EOF`返回`True`生成错误。 使用`LOF`和`Loc`函数而不是`EOF`与二进制文件中读取时`Input`，或使用`Get`时使用`EOF`函数。 打开以进行文件与`Output`，`EOF`始终返回`True`。  
  
   
  
## Examples  
 此示例使用`EOF`函数来检测文件末尾。 此示例假定`Testfile`是一个包含若干行文本的文本文件。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 <see langword="Integer" />。 任何有效文件数。</param>
        <summary>返回一个枚举，该枚举表示使用 <see langword="FileOpen" /> 函数打开的文件的文件模式。 与 <see langword="FileAttr" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>下列枚举值指示文件访问模式：  
  
 <list type="table"><item><term> 值  
  
 </term><description>模式  
  
 </description></item><item><term> 1  
  
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  
  
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  
  
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  
  
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  
  
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函数将返回一个枚举，表示使用打开的文件的文件模式`FileOpen`函数。  
  
   
  
## Examples  
 此示例使用`FileAttr`函数以返回打开的文件的文件模式。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">可选。 要关闭的 0 个或多个信道的参数数组。</param>
        <summary>关闭对用 <see langword="FileOpen" /> 函数打开的文件的输入/输出 (I/O)。 <see langword="My" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[如何： 使用 StreamReader 文件中读取文本](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)，[如何： 使用 StreamWriter 向文件写入文本](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)，和[演练： 中操作文件和目录Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)。  
  
 如果省略`FileNumbers`，所有活动文件打开`FileOpen`函数将关闭。  
  
 关闭已打开以进行文件`Output`或`Append`，最终输出缓冲区写入到该文件的操作系统缓冲区。 所有关联的缓冲区空间使用的已关闭发布文件。  
  
 当`FileClose`执行函数，而其文件的文件的关联是数字结束。  
  
   
  
## Examples  
 此示例使用`FileClose`函数要关闭的文件打开以进行`Input`。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必须的。 指定要复制的文件的名称的 <see langword="String" /> 表达式。 <c>Source</c> 可以包含源文件的目录或文件夹以及驱动器。</param>
        <param name="Destination">必须的。 指定目标文件名的 <see langword="String" /> 表达式。 <c>Destination</c> 可以包含目标文件的目录或文件夹以及驱动器。</param>
        <summary>复制文件。 与 <see langword="FileCopy" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你尝试使用`FileCopy`函数上当前打开的文件，将会出错。  
  
 `FileCopy` 需要完全信任才能在本地驱动器上工作。  
  
   
  
## Examples  
 此示例使用`FileCopy`函数将一个文件复制到另一个。 在此示例中，假定`SrcFile`是包含数据的文件。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> 或 <paramref name="Destination" /> 无效或未指定。</exception>
        <exception cref="T:System.IO.IOException">文件已打开。</exception>
        <exception cref="T:System.IO.FileNotFoundException">文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 指定一个文件名的 <see langword="String" /> 表达式。 <c>PathName</c> 可以包含目录或文件夹以及驱动器。</param>
        <summary>返回一个 <see langword="Date" /> 值，该值指示写入文件的日期和时间。 相比 <see langword="FileDateTime" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>
          <see langword="Date" /> 值，该值指示文件的创建日期和时间或上次修改日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`FileDateTime`函数来确定日期和时间文件已创建或上次修改。 显示日期和时间的格式取决于系统的区域设置。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> 无效或包含通配符。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通常写入到的文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通常写入到的文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符。 然后的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通常写入到的文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通常写入到的文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否为描述长度的字符串写入一个双字节说明符。 默认值为 <see langword="False" />。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <param name="ArrayIsDynamic">可选。 仅当写入数组时使用。 指定是否将数组视为动态数组，以及是否需要描述数组大小和边界的数组说明符。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否为描述长度的字符串写入一个双字节说明符。 默认值为 <see langword="False" />。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGet`通过使用通常写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。  
  
-   默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在读取数组时，必须以匹配写入数组的方式。 如果它使用描述符编写的必须读取描述符。 如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。  
  
     描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     分发了 218 个字节，如下所示：  
  
    -   描述符 18 个字节: (2 + 8 * 2)  
  
    -   200 字节的数据: (5 * 10 * 4)。  
  
-   如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`的只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。  相比 <see langword="FileGetObject" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject`而不是使用函数`FileGet`以避免多义性在编译时，如果类型`Object`会返回而不是另一个类型，如`Integer`， `Long`， `Short`，依次类推。  
  
 如果你想要写出`Variant`类型，`FileGetObject`是必需的。 当有疑问时，如果第二个参数使用一个对象，它始终建议你使用`FilePutObject`和`FileGetObject`。  
  
 `FileGetObject` 仅在中有效`Random`和`Binary`模式。  
  
 数据读取`FileGetObject`通常使用编写`FilePutObject`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`，`FileGetObject`上次读取的记录或字节`FileGetObject`或`FilePutObject`函数 (或指向由最后一个`Seek`函数)。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGetObject`读取的记录长度边界上的后续记录。 将文件缓冲区的现有内容，则填充一个记录的结尾和开头的下一条记录之间的空间。 因为无法精确地确定填充的数据量，最好具有匹配的数据被读取的长度的记录长度。  
  
-   如果读入的变量是一个字符串，默认情况下的`FileGetObject`读取包含字符串长度的两个字节描述符，然后读取放入变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串和读取到文件时，则不会写入长度描述符。 如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果读入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 参数指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度数： 2 + 8 * NumberOfDimensions。  
  
     例如，下面的数组声明需要 218 个字节时将数组写入到磁盘：  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     分发了 218 个字节，如下所示：为描述符分发了 18 个字节 (2 + 8 * 2)，为数据分发了 100 个字节 (5 * 10 * 4)。  
  
-   `FileGetObject` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePutObject`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀： 2 + 8 * NumberOfDimensions。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素，包括任何数组和其描述符所需的所有字节之和。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute>类可以应用于以指示字符串写入时的大小的结构中的 string 字段到磁盘。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，所有的`Random`规则适用，但存在下列例外：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FileGetObject` 读取所有变量从磁盘连续，即记录之间没有空白。  
  
-   对于在结构中，数组以外的任何数组`FileGetObject`的只读取数据。 未不读取任何说明符。  
  
 `FileGetObject` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已在字符串中的字符数。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
   
  
## Examples  
 下面的示例读入测试文件中读取一条记录，然后检索它。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 <see langword="String" /> 表达式，用于指定文件。 <c>PathName</c> 可以包含目录或文件夹以及驱动器。</param>
        <summary>返回 <see langword="Long" /> 值，该值以字节为单位指定文件长度。 相比 <see langword="FileLen" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>
          <see langword="Long" /> 值，该值以字节为单位指定文件长度。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的文件打开时`FileLen`被调用函数时，它已打开时，返回的值表示文件的大小。  
  
> [!NOTE]
>  若要获取的当前打开的文件的长度，请使用`LOF`函数。  
  
   
  
## Examples  
 此示例使用`FileLen`函数以返回文件的长度以字节为单位。 在此示例中，假定`TestFile`是包含一些数据的文件。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。 可使用 <see langword="FreeFile" /> 函数获取下一个可用的文件号。</param>
        <param name="FileName">必须的。 一个指定文件名的 <see langword="String" /> 表达式，其中可包含目录或文件夹以及驱动器。</param>
        <param name="Mode">必须的。 指定文件模式的枚举：<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" /> 或 <see langword="Random" />。 有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.OpenMode" />。</param>
        <param name="Access">可选。 一个枚举，它指定对打开的文件所允许进行的操作：<see langword="Read" />、<see langword="Write" /> 或 <see langword="ReadWrite" />。 默认为 <see langword="ReadWrite" />。 有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.OpenAccess" />。</param>
        <param name="Share">可选。 一个枚举，它指定不允许其他进程对打开的文件所进行的操作：<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" /> 和 <see langword="Lock Read Write" />。 默认为 <see langword="Lock Read Write" />。 有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.OpenShare" />。</param>
        <param name="RecordLength">可选。 小于或等于 32,767（字节）的数字。 对于为进行随机访问而打开的文件，此值是记录的长度。 对于顺序文件，此值是缓冲的字符数。</param>
        <summary>打开一个文件以进行输入或输出。 相比 <see langword="FileOpen" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 可以对其执行任何 I/O 操作之前，必须打开文件。 `FileOpen` 针对 I/O 分配缓冲区，文件并确定要用于缓冲区的访问模式。  
  
> [!IMPORTANT]
>  写入到文件时，应用程序可能需要创建一个文件，如果尝试写入的文件不存在。 为此，它将用用于创建文件的目录中需要的权限。 但是，如果指定的文件`FileName`确实存在，应用程序需求`Write`仅指向文件本身的权限。 可能有助于提高安全性，部署和授予期间创建文件的任何位置`Write`对该文件的权限仅，而不是整个目录。 为了提高安全性，请将数据写入到的根目录或 Program Files 目录的用户目录而不是。  
  
 若要打开的通道可通过使用找到`FreeFile()`函数。  
  
> [!IMPORTANT]
>  `FileOpen`函数需要`Read`从访问`FileIOPermissionAccess`枚举，从而可能影响在部分信任情况下其执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例演示如何的各种用法`FileOpen`函数，以使输入和输出到文件。  
  
 下面的代码中打开的文件`TestFile`中`Input`模式。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 此示例打开中的文件`Binary`进行只写操作的模式。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 下面的示例打开中的文件`Random`模式。 该文件包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 此代码示例将打开的文件中`Output`模式; 任何进程可以读取或写入文件。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 此代码示例将打开的文件中`Binary`模式供读取，则其他进程无法读取文件。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">记录长度是负数（并且不等于 -1）。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> 已经打开，或 <paramref name="FileName" /> 无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关更多信息，请参见 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否将字符串的双字节字符串长度说明符写入文件中。 默认值为 <see langword="False" />。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关更多信息，请参见 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <param name="ArrayIsDynamic">可选。 仅当写入数组时使用。 指定是否将数组视为动态数组，以及是否写入用于描述字符串长度的数组说明符。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否将字符串的双字节字符串长度说明符写入文件中。 默认值为 <see langword="False" />。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePut` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。 因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。 Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不能写描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。 指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。  
  
    > [!NOTE]
    >  字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。 在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数以将数据写入到文件。 结构的 5 个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。  相比 <see langword="FilePutObject" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject`而不是使用函数`FilePut`以避免多义性在编译时，如果类型`Object`而不是另一个类型，如传递`Integer`， `Long`， `Short`，依次类推。  
  
 `FilePutObject` 写入和读取描述对象的描述符。 如果你想要写出`Variant`类型，`FilePutObject`是必需的。 当有疑问时，如果第二个参数使用一个对象，我们建议您始终使用`FilePutObject`和`FileGetObject`。  
  
 `FilePutObject` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGetObject` 从文件中读取使用 `FilePutObject` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`，`FilePutObject`上次写入的下一步的记录或字节`FileGetObject`或`FilePutObject`函数 (或记录或字节指向由最后一个`Seek`函数)。  
  
 `StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。 `FilePutObject` 如果参数为本身不会写入长度描述符`True`。 如果你使用`StringIsFixedLength`  =  `True`与`FilePutObject`，您需要做相同，但有`FileGetObject`，和你还必须确保此字符串初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 打开的文件中`Random`模式下，以下规则适用：  
  
-   如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePutObject`将后续记录写入记录长度边界上。 将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。 因为无法精确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。 如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   写入的变量是否包含数值类型的对象`FilePutObject`写入两个字节以标识`VarType`的对象，然后将该变量。 例如，当编写一个对象时，包含一个整数，`FilePutObject`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePutObject`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。  
  
-   如果写入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 子句指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定的秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维数: (2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>二进制模式下  
 打开的文件中`Binary`模式下，所有`Random`模式规则适用，除外：  
  
-   `RecordLength`中的子句`FileOpen`函数不起任何作用。 `FilePutObject` 将所有变量磁盘连续，即包含无记录之间的填充。  
  
   
  
## Examples  
 此示例使用`FilePutObject`函数以向文件写入一个字符串。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="RecordWidth">必须的。 0 到 255（包括 0 和 255）范围内的数值表达式，它表示在开始新一行前每一行中所显示的字符数。 如果 <c>RecordWidth</c> 等于 0，则行的长度没有限制。 <c>RecordWidth</c> 的默认值为 0。</param>
        <summary>为用 <see langword="FileOpen" /> 函数打开的文件分配输出行宽。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`FileWidth`函数可设置文件的输出线条宽度。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个 <see langword="Integer" /> 值，该值表示 <see langword="FileOpen" /> 函数可用的下一个文件号。</summary>
        <returns>返回一个 <see langword="Integer" /> 值，该值表示 <see langword="FileOpen" /> 函数可用的下一个文件号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FreeFile`提供尚未使用文件数。  
  
   
  
## Examples  
 此示例使用`FreeFile`函数以返回下一个可用的文件数。 输出在循环中，打开五个文件和一些示例数据写入到每个。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">正在使用的文件数超过 255。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 指定一个文件名、目录名或文件夹名的 <see langword="String" /> 表达式。 <c>PathName</c> 可以包含目录或文件夹以及驱动器。</param>
        <summary>返回一个表示文件、目录或文件夹的特性的 <see langword="FileAttribute" /> 值。 相比 <see langword="FileAttribute" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>由 <see langword="GetAttr" /> 返回的值是下列枚举值的和：  
  
 <list type="table"><item><term> 值  
  
 </term><description> 常量  
  
 </description><description> 描述  
  
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> 常规。  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> 只读。  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> 隐藏。  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> 系统文件。  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> 目录或文件夹。  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> 文件自上次备份后已更改。  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> 文件具有不同的名称。  
  
 </description></item></list><block subset="none" type="note"><para>  
 这些枚举是由 Visual Basic 语言指定的。 可以在代码中的任何位置使用这些名称以代替实际值。  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定设置了哪些属性，请使用`And`运算符执行返回的值的按位比较`GetAttr`函数和所需的各个文件属性的值。 如果结果不为零，则该属性设置为指定的文件。 例如，以下的返回值`And`表达式是零 if`Archive`未设置属性：  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 如果返回非零值`Archive`属性设置。  
  
   
  
## Examples  
 此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> 无效或包含通配符。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有某些行写入到它使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有某些行写入到它使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Value">必须的。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`Input`通过使用通常写入到文件`Write`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据就赋给变量而不进行修改。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空白的行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式所表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是一个对象标记为错误）|  
  
 如果在输入数据项时达到文件末尾，输入已停止，则会出错。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="CharCount">必须的。 用于指定要读取的字符数的任何有效数值表达式。</param>
        <summary>返回 <see langword="String" /> 值，该值包含以 <see langword="Input" /> 或 <see langword="Binary" /> 模式打开的文件中的字符。 相比 <see langword="InputString" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>返回 <see langword="String" /> 值，该值包含以 <see langword="Input" /> 或 <see langword="Binary" /> 模式打开的文件中的字符。 相比 <see langword="InputString" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`InputString`函数通常通过使用写入到文件`Print`或`FilePut`。 此函数只能用于的文件在打开`Input`或`Binary`模式。  
  
 与不同`Input`函数，`InputString`函数返回它所读取的所有字符。 这包括逗号、 回车、 换行符、 引号引起来和前导空格。  
  
 打开以进行文件与`Binary`访问，请尝试使用读取通过文件`InputString`函数直到`EOF`返回`True`生成错误。 使用`LOF`和`Loc`函数而不是`EOF`时通过使用读取二进制文件`InputString`，或使用`FileGet`当你使用`EOF`函数。  
  
> [!NOTE]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关安全决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
   
  
## Examples  
 此示例使用`InputString`函数从文件一次读取一个字符并将其打印到`Output`窗口。 此示例假定`MyFile`是具有的示例数据的若干行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" />&lt; 0 或 &gt; 214。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 指定要删除的一个或多个文件名的 <see langword="String" /> 表达式。 <c>PathName</c> 可以包含目录或文件夹以及驱动器。</param>
        <summary>从磁盘中删除文件。 相比 <see langword="Kill" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` 支持使用多个字符 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 **安全说明**才能执行，`Kill`函数需要`Read`和`PathDiscovery`标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。 有关详细信息，请参阅<xref:System.Security.SecurityException>[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 此示例使用`Kill`函数从磁盘中删除文件。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">目标文件打开。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件未找到。</exception>
        <exception cref="T:System.Security.SecurityException">权限被拒绝。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <summary>从打开的顺序文件中读取一行并将其赋值给一个 <see langword="String" /> 变量。</summary>
        <returns>从打开的顺序文件中读取一行并将其赋值给一个 <see langword="String" /> 变量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 数据读取`LineInput`通过使用通常写入到文件`Print`。  
  
> [!IMPORTANT]
>  在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。 例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。  
  
 `LineInput`函数一次直到它遇到一个回车读取从文件的一个字符 (`Chr(13)`) 或回车/换行 (`Chr(13) + Chr(10)`) 序列。 回车符/换行符源的序列将跳过而不是追加到字符字符串。  
  
> [!IMPORTANT]
>  通过使用从文件读取`LineInput`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`LineInput`函数以从顺序文件中读取一个行并将其分配给变量。 此示例假定`TestFile`是具有的示例数据的若干行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">到达文件末尾。</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效的 <see langword="Integer" /> 文件号。</param>
        <summary>返回指定打开文件中当前读/写位置的 <see langword="Long" /> 值。</summary>
        <returns>返回指定打开文件中当前读/写位置的 <see langword="Long" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`函数是从零开始; 使用它来检索文件中的第一个字节将返回 0。  
  
 `Loc`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 下面介绍每种文件访问模式的返回值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入到文件的最新记录数。|  
|`Sequential`|除以 128 文件中的当前字节位置。 但是，通过返回信息`Loc`为顺序文件不是使用也不需要。|  
|`Binary`|读取或写入的最后一个字节的位置。|  
  
   
  
## Examples  
 此示例使用`Loc`函数以返回打开的文件中的当前读/写位置。 此示例假定`MyFile`是具有的示例数据的若干行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Record">可选。 唯一要锁定或取消锁定的记录号或字节数</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="FromRecord">可选。 第一个要锁定或取消锁定的记录号或字节数。</param>
        <param name="ToRecord">可选。 最后一个要锁定或取消锁定的记录号或字节数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 一个包含有效文件号的 <see langword="Integer" />。</param>
        <summary>返回一个 <see langword="Long" /> 值，该值表示使用 <see langword="FileOpen" /> 函数打开的文件的大小（以字节为单位）。 相比 <see langword="LOF" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>返回一个 <see langword="Long" /> 值，该值表示使用 <see langword="FileOpen" /> 函数打开的文件的大小（以字节为单位）。 相比 <see langword="LOF" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FileLen`函数来获取未打开的文件的长度。  
  
   
  
## Examples  
 此示例使用`LOF`函数来确定打开的文件的大小。 此示例假定`TestFile`是包含示例数据的文本文件。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必须的。 标识要创建的目录的 <see langword="String" /> 表达式。 <c>Path</c> 可以包含驱动器。 如果未指定驱动器，则 <see langword="MkDir" /> 在当前驱动器上创建新目录。</param>
        <summary>新建目录。 相比 <see langword="MkDir" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函数将创建一个新目录。  
  
   
  
## Examples  
 此示例使用`MkDir`函数来创建一个目录。 如果未指定驱动器，当前的驱动器上创建新目录。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 未指定或为空。</exception>
        <exception cref="T:System.Security.SecurityException">权限被拒绝。</exception>
        <exception cref="T:System.IO.IOException">目录已存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Output">可选。 要写入文件的零个或多个由逗号分隔的表达式。  
  
 <c>Output</c> 参数的设置是：  
  
 <see langword="T:System.IO.IOException" />：文件模式无效。  
  
 <see langword="T:System.IO.IOException" />：<c>FileNumber</c> 不存在。</param>
        <summary>将已设置显示格式的数据写入顺序文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包括换行符末尾的换行符。但是，`PrintLine`包括换行符。  
  
 数据使用编写`Print`从文件通常通过使用读取`LineInput`或`Input`。  
  
 如果省略`Output`为`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。 将在选项卡上边界，但混合使用逗号上对齐多个以逗号分隔的表达式和`TAB`可能会导致不一致的结果。  
  
 有关`Boolean`数据，`True`或`False`打印。 `True`和`False`无论区域设置如何，都不翻译关键字。  
  
 日期数据写入文件，通过使用你的系统所识别的标准短日期格式。 时的日期或时间组件缺失或为零时，仅提供部分是写入文件。  
  
 执行任何操作写入文件，如果`Output`数据为空。 但是，如果`Output`列表数据是`DBNull`，`Null`写入到文件。  
  
 有关`Error`数据，输出将显示为`Error errorcode`。 `Error`关键字不会进行转换而不考虑区域设置。  
  
 通过使用写入到文件的所有数据`Print`是国际通用的; 即，数据的格式正确使用适当的小数分隔符。 如果用户想要输出以供多个区域设置中，数据`Write`应使用。  
  
 通过使用对文件进行写入`Print`或`PrintLine`函数需要`Write`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Print`和`PrintLine`函数以将数据写入到文件。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Output">可选。 要写入文件的零个或多个由逗号分隔的表达式。  
  
 <c>Output</c> 参数的设置是：  
  
 <see langword="T:System.IO.IOException" />：文件模式无效。  
  
 <see langword="T:System.IO.IOException" />：<c>FileNumber</c> 不存在。</param>
        <summary>将已设置显示格式的数据写入顺序文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包括换行符末尾的换行符。但是，`PrintLine`包括换行符。  
  
 数据使用编写`Print`从文件通常通过使用读取`LineInput`或`Input`。  
  
 如果省略`Output`为`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。 将在选项卡上边界，但混合使用逗号上对齐多个以逗号分隔的表达式和`TAB`可能会导致不一致的结果。  
  
 有关`Boolean`数据，`True`或`False`打印。 `True`和`False`无论区域设置如何，都不翻译关键字。  
  
 日期数据写入文件，通过使用系统所识别的标准短日期格式。 时的日期或时间组件缺失或为零时，仅提供部分是写入文件。  
  
 执行任何操作写入文件，如果`Output`数据为空。 但是，如果`Output`列表数据是`DBNull`，`Null`写入到文件。  
  
 有关`Error`数据，输出将显示为`Error errorcode`。 `Error`关键字不会进行转换而不考虑区域设置。  
  
 通过使用写入到文件的所有数据`Print`是国际通用的; 即，数据的格式正确使用适当的小数分隔符。 如果用户想要输出以供多个区域设置中，数据`Write`应使用。  
  
 通过使用对文件进行写入`Print`或`PrintLine`函数需要`Write`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Print`和`PrintLine`函数以将数据写入到文件。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必须的。 指定现有文件名和位置的 <see langword="String" /> 表达式。 <c>OldPath</c> 可以包含文件的目录和驱动器。</param>
        <param name="NewPath">必须的。 指定新文件名和位置的 <see langword="String" /> 表达式。 <c>NewPath</c> 可以包含目标位置的目录和驱动器。 <c>NewPath</c> 指定的文件名不能是已存在的文件名。</param>
        <summary>重命名磁盘文件或目录。 相比 <see langword="Rename" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename`函数重命名文件，并将其移动到不同的目录，如有必要。 `Rename`函数可以将文件移个驱动器，但它仅可以重命名现有目录时同时`NewPath`和`OldPath`位于相同的驱动器上。 `Rename` 无法创建新文件或目录。  
  
 使用`Rename`函数对打开的文件产生错误。 重命名它前，必须先关闭打开的文件。 `Rename` 自变量不能包含多个字符 （*） 和单字符 （？） 通配符。  
  
> [!IMPORTANT]
>  使用时`Rename`以将文件从受保护的位置复制到受保护的位置，该文件，仍保持较低的限制的权限。 请检查以确保没有引入可能的安全风险。  
  
   
  
## Examples  
 此示例使用`Rename`函数重命名文件。 此示例的目的，假定已指定的目录存在。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路径无效。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> 文件不存在。</exception>
        <exception cref="T:System.IO.IOException">无法重命名为不同的设备。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭所有使用 <see langword="FileOpen" /> 函数打开的磁盘文件。 相比 <see langword="Reset" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset`函数关闭打开的所有活动文件`FileOpen`函数，并且具有相同的功能`FileClose()`不带任何参数。  
  
   
  
## Examples  
 此示例使用`Reset`函数以关闭所有打开的文件并将所有文件缓冲区的内容写入到磁盘。 请注意，使用`Object`变量`FileNumber`作为一个字符串和数字。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必须的。 标识要移除的目录或文件夹的 <see langword="String" /> 表达式。 <c>Path</c> 可以包含驱动器。 如果未指定驱动器，则 <see langword="RmDir" /> 移除当前驱动器上的目录。</param>
        <summary>移除现有目录。 相比 <see langword="RmDir" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你尝试使用，则会发生错误`RmDir`在包含文件的目录。 使用`Kill`函数以删除所有文件，然后尝试删除一个目录。  
  
   
  
## Examples  
 此示例使用`RmDir`函数来删除现有的目录。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> 未指定或为空。</exception>
        <exception cref="T:System.IO.IOException">目标目录包含文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目录不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 一个包含有效文件号的 <see langword="Integer" />。</param>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 返回一个值介于 1 和 2,147,483,647 之间 (等效于 2 ^31-1) （含）。  
  
 下面介绍每种文件访问模式的返回值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入的下一步记录号|  
|`Binary`, `Input`, `Output`, `Append`|下一步操作的发生的字节位置。 在文件中的第一个字节在位置 1，第二个字节在位置 2，依此类推。|  
  
   
  
## Examples  
 此示例使用`Seek`函数来返回当前的文件位置。 该示例假定`TestFile`是一个文件，包含的记录是结构`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 打开的文件中`Random`模式下，`Seek`返回下一条记录的数目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 而在模式下打开的文件`Random`模式下，`Seek`返回下一步操作的发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 此示例使用`Seek`函数将位置设置为下一步读取或写入的文件中。  
  
 而在模式下打开的文件`Random`模式下，`Seek`设置下一步操作的发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 一个包含有效文件号的 <see langword="Integer" />。</param>
        <param name="Position">必须的。 一个 1 到 2,147,483,647 范围内（包括 1 和 2,147,483,647）的数字，用于指示下一个读取/写入操作应该发生的位置。</param>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 返回一个值介于 1 和 2,147,483,647 之间 (等效于 2 ^31-1) （含）。  
  
 下面介绍每种文件访问模式的返回值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入的下一步记录号|  
|`Binary`, `Input`, `Output`, `Append`|下一步操作的发生的字节位置。 在文件中的第一个字节在位置 1，第二个字节在位置 2，依此类推。|  
  
   
  
## Examples  
 此示例使用`Seek`函数来返回当前的文件位置。 该示例假定`TestFile`是一个文件，包含的记录是结构`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 打开的文件中`Random`模式下，`Seek`返回下一条记录的数目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 而在模式下打开的文件`Random`模式下，`Seek`返回下一步操作的发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 此示例使用`Seek`函数将位置设置为下一步读取或写入的文件中。  
  
 而在模式下打开的文件`Random`模式下，`Seek`设置下一步操作的发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必须的。 指定一个文件名的 <see langword="String" /> 表达式。 <c>PathName</c> 可以包含驱动器和目录或文件夹。</param>
        <param name="Attributes">必须的。 常量或数值表达式，所有这些值一起指定文件特性。</param>
        <summary>设置文件的特性信息。 相比 <see langword="SetAttr" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您尝试设置打开的文件的属性，则会发生运行时错误。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbNormal`|正常 （默认值）。|  
|`ReadOnly`|`vbReadOnly`|只读。|  
|`Hidden`|`vbHidden`|隐藏。|  
|`System`|`vbSystem`|系统文件。|  
|`Volume`|`vbVolume`|卷标|  
|`Directory`|`vbDirectory`|目录或文件夹。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举是由 Visual Basic 语言指定的。 名称可以使用而非实际值在代码中的任意位置。  
  
   
  
## Examples  
 此示例使用`SetAttr`函数可设置文件的特性。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> 类型无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必须的。 在显示或输出列表中下一个表达式之前要插入的空格数。</param>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Count`小于输出线条宽度下, 一步打印位置立即遵循的打印的空格数。 如果`Count`大于输出线条宽度，`SPC`计算使用公式的下一步打印位置：  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 例如，如果打印当前位置为 24，输出行宽度为 80，并指定`SPC(90)`，则下一步打印将开始从位置 34 （打印当前位置 + 90/80 的余数）。 如果当前打印位置和输出线条宽度之间的区别在于小于`Count`(或`Count` `Mod` *宽度*)，则`SPC`函数将跳到下一步的行的开头，并生成空间等于`Count`– (*宽度*–*小于*)。  
  
> [!NOTE]
>  请确保表格列的宽度足以容纳较宽的字母。  
  
   
  
## Examples  
 此示例使用`SPC`函数位置输出文件中和在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在当前行的当前打印位置大于`Column`，`TAB`跳过为列的值等于`Column`下一步的输出行上。 如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。 如果`Column`大于输出线条宽度，`TAB`计算使用公式的下一步打印位置：  
  
 Mod 列宽  
  
 例如，如果*宽度*是 80，并指定`TAB(90)`，则下一个打印将开始列 10 （90/80 的余数）。 如果`Column`小于当前打印位置，在下一行计算的输出位置的打印启动。 如果计算出的打印位置大于当前打印位置，打印开始计算在同一行上打印位置。  
  
 在输出行上的最左边打印位置始终为 1。 当你使用`Print`或`PrintLine`函数来打印到文件，最右边的打印位置是输出文件中，你可以使用设置的当前宽度`FileWidth`函数。  
  
 `TAB`函数还可用于`WriteLine`函数。 它不能与使用<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  请确保表格列的宽度足以包含较宽的字母。  
  
   
  
## Examples  
 此示例使用`TAB`函数位置输出文件中和在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">可选。 在显示或输出列表中下一个表达式之前要移动到的列号。 如果省略它，则 <see langword="TAB" /> 将插入点移动到下一个打印区域的开始位置。</param>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在当前行的当前打印位置大于`Column`，`TAB`跳过为列的值等于`Column`下一步的输出行上。 如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。 如果`Column`大于输出线条宽度，`TAB`计算使用公式的下一步打印位置：  
  
 Mod 列宽  
  
 例如，如果*宽度*是 80，并指定`TAB(90)`，则下一个打印将开始列 10 （90/80 的余数）。 如果`Column`小于当前打印位置，在下一行计算的输出位置的打印启动。 如果计算出的打印位置大于当前打印位置，打印开始计算在同一行上打印位置。  
  
 在输出行上的最左边打印位置始终为 1。 当你使用`Print`或`PrintLine`函数来打印到文件，最右边的打印位置是输出文件中，你可以使用设置的当前宽度`FileWidth`函数。  
  
 `TAB`函数还可用于`WriteLine`函数。 它不能与使用<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  请确保表格列的宽度足以包含较宽的字母。  
  
   
  
## Examples  
 此示例使用`TAB`函数位置输出文件中和在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="Record">可选。 唯一要锁定或取消锁定的记录号或字节数</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 任何有效文件数。</param>
        <param name="FromRecord">可选。 第一个要锁定或取消锁定的记录号或字节数。</param>
        <param name="ToRecord">可选。 最后一个要锁定或取消锁定的记录号或字节数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 自变量`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 包含任何有效文件数的 <see langword="Integer" /> 表达式。</param>
        <param name="Output">可选。 要写入文件的一个或多个由逗号分隔的表达式。</param>
        <summary>将数据写入一个顺序文件。 通常使用 <see langword="Input" /> 从文件中读取使用 <see langword="Write" /> 编写的数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果省略`Output`，向文件打印一个空行。 可以用逗号分隔多个表达式。  
  
 与不同`Print`函数，`Write`函数插入项与字符串周围的引号之间的逗号，按它们写入到文件的形式。 无需显式分隔符放入列表。 当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。 下面的通用假设遵循这样的数据始终能够阅读和使用正确的解释`Input`，而不考虑区域设置：  
  
-   使用句点作为小数分隔符始终写入数值数据。  
  
-   有关`Boolean`数据，`#TRUE#`或`#FALSE#`打印。 `True`和`False`无论区域设置如何，都不翻译关键字。  
  
-   日期数据写入到使用的通用日期格式的文件。 时的日期或时间组件缺失或为零时，仅提供部分是写入文件。  
  
-   执行任何操作写入文件，如果`Output`数据为空。 但是，对于 null 数据一样，`#NULL#`写入。  
  
-   有关`Error`数据，输出将显示为`#ERROR errorcode#`。 `Error`不转换关键字，而不考虑区域设置。  
  
 `WriteLine` 将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`文件。  
  
 可以在字符串中嵌入引号引起来通过使用双引号括起来，或""。 例如，应用于对象的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 返回的值的字符串`Double quotation marks aren't "difficult" to handle`。  
  
 通过使用对文件进行写入`Write`或`WriteLine`函数需要`Append`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Write`函数以将原始数据写入到顺序的文件。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必须的。 包含任何有效文件数的 <see langword="Integer" /> 表达式。</param>
        <param name="Output">可选。 要写入文件的一个或多个由逗号分隔的表达式。</param>
        <summary>将数据写入一个顺序文件。 通常使用 <see langword="Input" /> 从文件中读取使用 <see langword="Write" /> 编写的数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函数提供用于向后兼容性，并且可能会影响性能。 对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果省略`Output`，向文件打印一个空行。 可以用逗号分隔多个表达式。  
  
 与不同`Print`函数，`Write`函数插入项与字符串周围的引号之间的逗号，按它们写入到文件的形式。 无需显式分隔符放入列表。 当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。 下面的通用假设遵循这样的数据始终能够阅读和使用正确的解释`Input`，而不考虑区域设置：  
  
-   使用句点作为小数分隔符始终写入数值数据。  
  
-   有关`Boolean`数据，`#TRUE#`或`#FALSE#`打印。 `True`和`False`无论区域设置如何，都不翻译关键字。  
  
-   日期数据写入到使用的通用日期格式的文件。 时的日期或时间组件缺失或为零时，仅提供部分是写入文件。  
  
-   执行任何操作写入文件，如果`Output`数据为空。 但是，对于 null 数据一样，`#NULL#`写入。  
  
-   有关`Error`数据，输出将显示为`#ERROR errorcode#`。 `Error`不转换关键字，而不考虑区域设置。  
  
 `WriteLine` 将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`文件。  
  
 可以在字符串中嵌入引号引起来通过使用双引号括起来，或""。 例如，应用于对象的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 返回的值的字符串`Double quotation marks aren't "difficult" to handle`。  
  
 通过使用对文件进行写入`Write`或`WriteLine`函数需要`Append`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Write`函数以将原始数据写入到顺序的文件。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>