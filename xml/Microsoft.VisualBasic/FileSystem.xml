<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="46b80-101"><see langword="FileSystem" /> 模块包含用于执行文件、目录或文件夹以及系统操作的过程。</span><span class="sxs-lookup"><span data-stu-id="46b80-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span></span> <span data-ttu-id="46b80-102">与使用 <see langword="My" /> 模块相比，<see langword="FileSystem" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span></span> <span data-ttu-id="46b80-103">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-104">此模块支持的 Visual Basic 语言关键字和访问文件和文件夹的运行时库成员。</span><span class="sxs-lookup"><span data-stu-id="46b80-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-105">此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。</span><span class="sxs-lookup"><span data-stu-id="46b80-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="46b80-106">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-106">Required.</span></span> <span data-ttu-id="46b80-107">一个 <see langword="String" /> 表达式，用于标识哪个目录或文件夹将成为新的默认目录或文件夹。</span><span class="sxs-lookup"><span data-stu-id="46b80-107">A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder.</span></span> <span data-ttu-id="46b80-108"><c>Path</c> 可以包含驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-108"><c>Path</c> may include the drive.</span></span> <span data-ttu-id="46b80-109">如果未指定驱动器，则 <see langword="ChDir" /> 更改当前驱动器上的默认目录或文件夹。</span><span class="sxs-lookup"><span data-stu-id="46b80-109">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span></span></param>
        <summary><span data-ttu-id="46b80-110">更改当前目录或文件夹。</span><span class="sxs-lookup"><span data-stu-id="46b80-110">Changes the current directory or folder.</span></span> <span data-ttu-id="46b80-111">与 <see langword="My" /> 函数相比，<see langword="ChDir" /> 功能在文件 I/O 操作方面可提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-111">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span></span> <span data-ttu-id="46b80-112">有关详细信息，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-112">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-113">`ChDir`函数更改默认的目录，但不是在默认驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-113">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="46b80-114">例如，如果默认驱动器 C，以下语句会更改驱动器 D 上的默认目录，但 C 保留默认驱动器：</span><span class="sxs-lookup"><span data-stu-id="46b80-114">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="46b80-115">你可以相对目录更改为通过键入两个句点，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-115">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-116">`ChDir`函数需要非托管的代码的权限，这可能会影响在部分信任情况下其执行。</span><span class="sxs-lookup"><span data-stu-id="46b80-116">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="46b80-117">有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和。</span><span class="sxs-lookup"><span data-stu-id="46b80-117">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-118">此示例使用`ChDir`函数来更改当前目录或文件夹。</span><span class="sxs-lookup"><span data-stu-id="46b80-118">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-119"><paramref name="Path" /> 为空。</span><span class="sxs-lookup"><span data-stu-id="46b80-119"><paramref name="Path" /> is empty.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="46b80-120">指定的驱动器无效，或驱动器不可用。</span><span class="sxs-lookup"><span data-stu-id="46b80-120">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-121">更改当前驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-121">Changes the current drive.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="46b80-122">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-122">Required.</span></span> <span data-ttu-id="46b80-123">指定现有驱动器的字符串表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-123">String expression that specifies an existing drive.</span></span> <span data-ttu-id="46b80-124">如果提供一个零长度字符串 ("")，则当前驱动器不会更改。</span><span class="sxs-lookup"><span data-stu-id="46b80-124">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="46b80-125">如果 <c>Drive</c> 参数为多字符字符串，<see langword="ChDrive" /> 将仅使用第一个字母。</span><span class="sxs-lookup"><span data-stu-id="46b80-125">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="46b80-126">更改当前驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-126">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-127">`ChDrive`函数需要非托管代码的权限，这可能会影响在部分信任情况下其执行。</span><span class="sxs-lookup"><span data-stu-id="46b80-127">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="46b80-128">有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。</span><span class="sxs-lookup"><span data-stu-id="46b80-128">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-129">此示例使用`ChDrive`函数来更改当前驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-129">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="46b80-130">如果驱动器不存在，则函数将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-130">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-131">指定的驱动器无效，或驱动器不可用。</span><span class="sxs-lookup"><span data-stu-id="46b80-131">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="46b80-132">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-132">Required.</span></span> <span data-ttu-id="46b80-133">指定现有驱动器的字符串表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-133">String expression that specifies an existing drive.</span></span> <span data-ttu-id="46b80-134">如果提供一个零长度字符串 ("")，则当前驱动器不会更改。</span><span class="sxs-lookup"><span data-stu-id="46b80-134">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="46b80-135">如果 <c>Drive</c> 参数为多字符字符串，<see langword="ChDrive" /> 将仅使用第一个字母。</span><span class="sxs-lookup"><span data-stu-id="46b80-135">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="46b80-136">更改当前驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-136">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-137">`ChDrive`函数需要非托管代码的权限，这可能会影响在部分信任情况下其执行。</span><span class="sxs-lookup"><span data-stu-id="46b80-137">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="46b80-138">有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。</span><span class="sxs-lookup"><span data-stu-id="46b80-138">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-139">此示例使用`ChDrive`函数来更改当前驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-139">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="46b80-140">如果驱动器不存在，则函数将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-140">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-141">指定的驱动器无效，或驱动器不可用。</span><span class="sxs-lookup"><span data-stu-id="46b80-141">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-142">返回表示当前路径的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-142">Returns a string representing the current path.</span></span> <span data-ttu-id="46b80-143">与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-143">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="46b80-144">有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-144">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="46b80-145">返回表示当前路径的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-145">Returns a string representing the current path.</span></span> <span data-ttu-id="46b80-146">与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-146">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="46b80-147">有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-147">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="46b80-148">表示当前路径的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-148">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="46b80-149">此示例使用`CurDir`函数以返回当前路径。</span><span class="sxs-lookup"><span data-stu-id="46b80-149">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="46b80-150">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-150">Optional.</span></span> <span data-ttu-id="46b80-151">指定现有驱动器的 <see langword="Char" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-151"><see langword="Char" /> expression that specifies an existing drive.</span></span> <span data-ttu-id="46b80-152">如果未指定驱动器或 <c>Drive</c> 是零长度字符串 ("")，则 <see langword="CurDir" /> 返回当前驱动器的路径。</span><span class="sxs-lookup"><span data-stu-id="46b80-152">If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span></span></param>
        <summary><span data-ttu-id="46b80-153">返回表示当前路径的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-153">Returns a string representing the current path.</span></span> <span data-ttu-id="46b80-154">与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="46b80-155">有关详情，请参阅<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="46b80-156">表示当前路径的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-156">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="46b80-157">此示例使用`CurDir`函数以返回当前路径。</span><span class="sxs-lookup"><span data-stu-id="46b80-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-158">返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。</span><span class="sxs-lookup"><span data-stu-id="46b80-158">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="46b80-159">与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-159">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="46b80-160">有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-160">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="46b80-161">返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。</span><span class="sxs-lookup"><span data-stu-id="46b80-161">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="46b80-162">与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="46b80-163">有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-163">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="46b80-164">一个字符串，表示与指定模式或文件特性匹配的文件、目录或文件夹的名称，或者表示驱动器卷标。</span><span class="sxs-lookup"><span data-stu-id="46b80-164">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-165">`Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-165">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="46b80-166">`VbVolume` 返回而不是特定文件名的驱动器的卷标签。</span><span class="sxs-lookup"><span data-stu-id="46b80-166">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="46b80-167">必须提供`PathName`第一次调用`Dir`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-167">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="46b80-168">若要检索的下一项，你可以后续调用`Dir`不带参数的函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-168">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-169">若要正确运行，`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>和<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。</span><span class="sxs-lookup"><span data-stu-id="46b80-169">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="46b80-170">有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。</span><span class="sxs-lookup"><span data-stu-id="46b80-170">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="46b80-171">`Attributes`参数枚举值如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-171">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="46b80-172">“值”</span><span class="sxs-lookup"><span data-stu-id="46b80-172">Value</span></span>|<span data-ttu-id="46b80-173">返回的常量</span><span class="sxs-lookup"><span data-stu-id="46b80-173">Constant</span></span>|<span data-ttu-id="46b80-174">描述</span><span class="sxs-lookup"><span data-stu-id="46b80-174">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="46b80-175">默认。</span><span class="sxs-lookup"><span data-stu-id="46b80-175">Default.</span></span> <span data-ttu-id="46b80-176">指定无特性文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-176">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="46b80-177">指定只读文件，以及带属性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-177">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="46b80-178">指定隐藏的文件，以及带属性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-178">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="46b80-179">指定系统文件，以及带属性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-179">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="46b80-180">指定卷标签;如果指定其他任何属性，则`vbVolume`将被忽略。</span><span class="sxs-lookup"><span data-stu-id="46b80-180">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="46b80-181">指定目录或文件夹，以及带属性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-181">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="46b80-182">文件自上次备份后已更改。</span><span class="sxs-lookup"><span data-stu-id="46b80-182">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="46b80-183">文件具有不同的名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-183">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="46b80-184">这些枚举由 Visual Basic 语言指定，并且可以使用而非实际值在代码中的任意位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-184">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-185">此示例使用`Dir`函数来检查某些文件和目录是否存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-185">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="46b80-186">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-186">Optional.</span></span> <span data-ttu-id="46b80-187"><see langword="String" /> 表达式，用于指定文件名、目录或文件夹名或者驱动器卷标。</span><span class="sxs-lookup"><span data-stu-id="46b80-187"><see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label.</span></span> <span data-ttu-id="46b80-188">如果未找到 <c>PathName</c>，则返回一个零长度字符串 (<see langword="&quot;&quot;" />)。</span><span class="sxs-lookup"><span data-stu-id="46b80-188">A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</span></span></param>
        <param name="Attributes"><span data-ttu-id="46b80-189">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-189">Optional.</span></span> <span data-ttu-id="46b80-190">其值指定文件特性的枚举或数值表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-190">Enumeration or numeric expression whose value specifies file attributes.</span></span> <span data-ttu-id="46b80-191">如果省略，则 <see langword="Dir" /> 将返回与 <c>PathName</c> 匹配但不具有任何特性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-191">If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</span></span></param>
        <summary><span data-ttu-id="46b80-192">返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。</span><span class="sxs-lookup"><span data-stu-id="46b80-192">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="46b80-193">与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-193">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="46b80-194">有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-194">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="46b80-195">一个字符串，表示与指定模式或文件特性匹配的文件、目录或文件夹的名称，或者表示驱动器卷标。</span><span class="sxs-lookup"><span data-stu-id="46b80-195">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-196">`Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-196">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="46b80-197">`VbVolume` 返回而不是特定文件名的驱动器的卷标签。</span><span class="sxs-lookup"><span data-stu-id="46b80-197">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="46b80-198">必须提供`PathName`第一次调用`Dir`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-198">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="46b80-199">若要检索的下一项，你可以后续调用`Dir`不带任何参数的函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-199">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-200">若要正确运行，`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>和<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。</span><span class="sxs-lookup"><span data-stu-id="46b80-200">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="46b80-201">有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，和[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。</span><span class="sxs-lookup"><span data-stu-id="46b80-201">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="46b80-202">`Attributes`参数枚举值如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-202">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="46b80-203">“值”</span><span class="sxs-lookup"><span data-stu-id="46b80-203">Value</span></span>|<span data-ttu-id="46b80-204">返回的常量</span><span class="sxs-lookup"><span data-stu-id="46b80-204">Constant</span></span>|<span data-ttu-id="46b80-205">描述</span><span class="sxs-lookup"><span data-stu-id="46b80-205">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="46b80-206">默认。</span><span class="sxs-lookup"><span data-stu-id="46b80-206">Default.</span></span> <span data-ttu-id="46b80-207">指定无特性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-207">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="46b80-208">指定只读文件，除了不具任何属性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-208">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="46b80-209">指定隐藏的文件，除了不具任何属性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-209">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="46b80-210">指定系统文件，除了不具任何属性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-210">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="46b80-211">指定卷标签;如果指定其他任何属性，则`vbVolume`将被忽略。</span><span class="sxs-lookup"><span data-stu-id="46b80-211">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="46b80-212">指定目录或文件夹，以及不具任何属性的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-212">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="46b80-213">文件自上次备份后已更改。</span><span class="sxs-lookup"><span data-stu-id="46b80-213">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="46b80-214">文件具有不同的名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-214">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="46b80-215">这些枚举由 Visual Basic 语言指定，并且可以使用的实际值替换代码中的任意位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-215">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-216">此示例使用`Dir`函数来检查某些文件和目录是否存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-216">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-217">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-217">Required.</span></span> <span data-ttu-id="46b80-218">一个包含任何有效文件号的 <see langword="Integer" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-218">An <see langword="Integer" /> that contains any valid file number.</span></span></param>
        <summary><span data-ttu-id="46b80-219">当达到为进行 <see langword="True" /> 或顺序 <see langword="Random" /> 而打开的文件的结尾时，此方法返回布尔值 <see langword="Input" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-219">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></summary>
        <returns><span data-ttu-id="46b80-220">当达到为进行 <see langword="True" /> 或顺序 <see langword="Random" /> 而打开的文件的结尾时，此方法返回布尔值 <see langword="Input" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-220">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-221">使用`EOF`以避免通过尝试获取输入文件的末尾而产生的错误。</span><span class="sxs-lookup"><span data-stu-id="46b80-221">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="46b80-222">`EOF`函数返回`False`之前已到达文件末尾。</span><span class="sxs-lookup"><span data-stu-id="46b80-222">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="46b80-223">打开以进行文件与`Random`或`Binary`访问，`EOF`返回`False`直到最后一个执行`FileGet`函数不能读取完整记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-223">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="46b80-224">打开以进行文件与`Binary`访问，请尝试通过文件使用读取`Input`函数直到`EOF`返回`True`生成错误。</span><span class="sxs-lookup"><span data-stu-id="46b80-224">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="46b80-225">使用`LOF`和`Loc`函数而不是`EOF`与二进制文件中读取时`Input`，或使用`Get`时使用`EOF`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-225">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="46b80-226">打开以进行文件与`Output`，`EOF`始终返回`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-226">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-227">此示例使用`EOF`函数来检测文件末尾。</span><span class="sxs-lookup"><span data-stu-id="46b80-227">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="46b80-228">此示例假定`Testfile`是一个包含若干行文本的文本文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-228">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-229">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-229">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-230">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-230">Required.</span></span> <span data-ttu-id="46b80-231"><see langword="Integer" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-231"><see langword="Integer" />.</span></span> <span data-ttu-id="46b80-232">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-232">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="46b80-233">返回一个枚举，该枚举表示使用 <see langword="FileOpen" /> 函数打开的文件的文件模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-233">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="46b80-234">与 <see langword="FileAttr" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-234">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span></span> <span data-ttu-id="46b80-235">有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-235">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="46b80-236">下列枚举值指示文件访问模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-236">The following enumeration values indicate the file access mode:</span></span>  
  
 <span data-ttu-id="46b80-237"><list type="table"><item><term> 值</span><span class="sxs-lookup"><span data-stu-id="46b80-237"><list type="table"><item><term> Value</span></span>  
  
 <span data-ttu-id="46b80-238"></term><description>模式</span><span class="sxs-lookup"><span data-stu-id="46b80-238"></term><description> Mode</span></span>  
  
 <span data-ttu-id="46b80-239"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="46b80-239"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="46b80-240"></term><description><see langword="OpenMode.Input" /></description></item><item><term> 2</span><span class="sxs-lookup"><span data-stu-id="46b80-240"></term><description><see langword="OpenMode.Input" /></description></item><item><term> 2</span></span>  
  
 <span data-ttu-id="46b80-241"></term><description><see langword="OpenMode.Output" /></description></item><item><term> 4</span><span class="sxs-lookup"><span data-stu-id="46b80-241"></term><description><see langword="OpenMode.Output" /></description></item><item><term> 4</span></span>  
  
 <span data-ttu-id="46b80-242"></term><description><see langword="OpenMode.Random" /></description></item><item><term> 8</span><span class="sxs-lookup"><span data-stu-id="46b80-242"></term><description><see langword="OpenMode.Random" /></description></item><item><term> 8</span></span>  
  
 <span data-ttu-id="46b80-243"></term><description><see langword="OpenMode.Append" /></description></item><item><term> 32</span><span class="sxs-lookup"><span data-stu-id="46b80-243"></term><description><see langword="OpenMode.Append" /></description></item><item><term> 32</span></span>  
  
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-244">此函数将返回一个枚举，表示使用打开的文件的文件模式`FileOpen`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-244">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-245">此示例使用`FileAttr`函数以返回打开的文件的文件模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-245">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers"><span data-ttu-id="46b80-246">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-246">Optional.</span></span> <span data-ttu-id="46b80-247">要关闭的 0 个或多个信道的参数数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-247">Parameter array of 0 or more channels to be closed.</span></span></param>
        <summary><span data-ttu-id="46b80-248">关闭对用 <see langword="FileOpen" /> 函数打开的文件的输入/输出 (I/O)。</span><span class="sxs-lookup"><span data-stu-id="46b80-248">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="46b80-249"><see langword="My" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-249"><see langword="My" /> gives you better productivity and performance in file I/O operations.</span></span> <span data-ttu-id="46b80-250">有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-250">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-251">`FileClose`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-251">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-252">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-252">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-253">有关详细信息，请参阅[如何： 使用 StreamReader 文件中读取文本](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)，[如何： 使用 StreamWriter 向文件写入文本](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)，和[演练： 中操作文件和目录Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-253">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="46b80-254">如果省略`FileNumbers`，所有活动文件打开`FileOpen`函数将关闭。</span><span class="sxs-lookup"><span data-stu-id="46b80-254">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="46b80-255">关闭已打开以进行文件`Output`或`Append`，最终输出缓冲区写入到该文件的操作系统缓冲区。</span><span class="sxs-lookup"><span data-stu-id="46b80-255">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="46b80-256">所有关联的缓冲区空间使用的已关闭发布文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-256">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="46b80-257">当`FileClose`执行函数，而其文件的文件的关联是数字结束。</span><span class="sxs-lookup"><span data-stu-id="46b80-257">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-258">此示例使用`FileClose`函数要关闭的文件打开以进行`Input`。</span><span class="sxs-lookup"><span data-stu-id="46b80-258">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="46b80-259"><paramref name="FileNumber" /> 不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-259"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source"><span data-ttu-id="46b80-260">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-260">Required.</span></span> <span data-ttu-id="46b80-261">指定要复制的文件的名称的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-261"><see langword="String" /> expression that specifies the name of the file to be copied.</span></span> <span data-ttu-id="46b80-262"><c>Source</c> 可以包含源文件的目录或文件夹以及驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-262"><c>Source</c> may include the directory or folder, and drive, of the source file.</span></span></param>
        <param name="Destination"><span data-ttu-id="46b80-263">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-263">Required.</span></span> <span data-ttu-id="46b80-264">指定目标文件名的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-264"><see langword="String" /> expression that specifies the destination file name.</span></span> <span data-ttu-id="46b80-265"><c>Destination</c> 可以包含目标文件的目录或文件夹以及驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-265"><c>Destination</c> may include the directory or folder, and drive, of the destination file.</span></span></param>
        <summary><span data-ttu-id="46b80-266">复制文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-266">Copies a file.</span></span> <span data-ttu-id="46b80-267">与 <see langword="FileCopy" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-267">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span></span> <span data-ttu-id="46b80-268">有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-268">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-269">如果你尝试使用`FileCopy`函数上当前打开的文件，将会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-269">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="46b80-270">`FileCopy` 需要完全信任才能在本地驱动器上工作。</span><span class="sxs-lookup"><span data-stu-id="46b80-270">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-271">此示例使用`FileCopy`函数将一个文件复制到另一个。</span><span class="sxs-lookup"><span data-stu-id="46b80-271">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="46b80-272">在此示例中，假定`SrcFile`是包含数据的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-272">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-273"><paramref name="Source" /> 或 <paramref name="Destination" /> 无效或未指定。</span><span class="sxs-lookup"><span data-stu-id="46b80-273"><paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-274">文件已打开。</span><span class="sxs-lookup"><span data-stu-id="46b80-274">File is already open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="46b80-275">文件不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-275">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="46b80-276">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-276">Required.</span></span> <span data-ttu-id="46b80-277">指定一个文件名的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-277"><see langword="String" /> expression that specifies a file name.</span></span> <span data-ttu-id="46b80-278"><c>PathName</c> 可以包含目录或文件夹以及驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-278"><c>PathName</c> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="46b80-279">返回一个 <see langword="Date" /> 值，该值指示写入文件的日期和时间。</span><span class="sxs-lookup"><span data-stu-id="46b80-279">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span></span> <span data-ttu-id="46b80-280">相比 <see langword="FileDateTime" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-280">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span></span> <span data-ttu-id="46b80-281">有关详细信息，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-281">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span></span></summary>
        <returns>
          <span data-ttu-id="46b80-282"><see langword="Date" /> 值，该值指示文件的创建日期和时间或上次修改日期和时间。</span><span class="sxs-lookup"><span data-stu-id="46b80-282"><see langword="Date" /> value that indicates the date and time a file was created or last modified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="46b80-283">此示例使用`FileDateTime`函数来确定日期和时间文件已创建或上次修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-283">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="46b80-284">显示日期和时间的格式取决于系统的区域设置。</span><span class="sxs-lookup"><span data-stu-id="46b80-284">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-285"><paramref name="PathName" /> 无效或包含通配符。</span><span class="sxs-lookup"><span data-stu-id="46b80-285"><paramref name="PathName" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="46b80-286">目标文件不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-286">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-287">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-287">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-288">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-288">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-289">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-289">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-290">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-290">Required.</span></span> <span data-ttu-id="46b80-291">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-291">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-292">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-292">Required.</span></span> <span data-ttu-id="46b80-293">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-293">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-294">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-294">Optional.</span></span> <span data-ttu-id="46b80-295">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-295">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-296">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-296">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-297">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-297">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-298">有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-298">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-299">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-299">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-300">数据读取`FileGet`通常写入到的文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-300">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-301">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-301">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-302">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-302">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-303">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-303">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-304">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-304">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-305">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-305">Random Mode</span></span>  
 <span data-ttu-id="46b80-306">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-306">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-307">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-307">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-308">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-308">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-309">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-309">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-310">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-310">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-311">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-311">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-312">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-312">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-313">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-313">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-314">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-314">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-315">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-315">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-316">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-316">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-317">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-317">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-318">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-318">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-319">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-319">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-320">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-320">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-321">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-321">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-322">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-322">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-323">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-323">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-324">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-324">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-325">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-325">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-326">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-326">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-327">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-327">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-328">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-328">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-329">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-329">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-330">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-330">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-331">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-331">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-332">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-332">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-333">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-333">Binary Mode</span></span>  
 <span data-ttu-id="46b80-334">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-334">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-335">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-335">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-336">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-336">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-337">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-337">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-338">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-338">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-339">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-339">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-340">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-340">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-341">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-341">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-342">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-342">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-343"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-343"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-344">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-344">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-345">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-345">Required.</span></span> <span data-ttu-id="46b80-346">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-346">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-347">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-347">Required.</span></span> <span data-ttu-id="46b80-348">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-348">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-349">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-349">Optional.</span></span> <span data-ttu-id="46b80-350">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-350">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-351">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-351">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-352">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-352">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-353">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-353">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-354">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-354">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-355">数据读取`FileGet`通常写入到的文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-355">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-356">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-356">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-357">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-357">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-358">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-358">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-359">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-359">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-360">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-360">Random Mode</span></span>  
 <span data-ttu-id="46b80-361">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-361">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-362">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-362">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-363">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-363">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-364">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-364">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-365">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-365">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-366">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-366">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-367">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-367">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-368">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-368">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-369">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-369">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-370">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-370">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-371">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-371">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-372">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-372">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-373">如果不使用说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-373">If the descriptor is not used.</span></span> <span data-ttu-id="46b80-374">然后的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-374">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-375">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-375">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-376">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-376">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-377">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-377">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-378">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-378">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-379">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-379">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-380">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-380">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-381">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-381">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-382">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-382">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-383">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-383">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-384">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-384">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-385">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-385">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-386">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-386">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-387">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-387">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-388">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-388">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-389">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-389">Binary Mode</span></span>  
 <span data-ttu-id="46b80-390">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-390">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-391">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-391">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-392">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-392">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-393">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-393">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-394">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-394">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-395">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-395">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-396">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-396">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-397">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-397">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-398">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-398">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-399"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-399"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-400">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-400">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-401">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-401">Required.</span></span> <span data-ttu-id="46b80-402">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-402">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-403">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-403">Required.</span></span> <span data-ttu-id="46b80-404">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-404">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-405">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-405">Optional.</span></span> <span data-ttu-id="46b80-406">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-406">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-407">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-407">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-408">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-408">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-409">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-409">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-410">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-410">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-411">数据读取`FileGet`通常写入到的文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-411">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-412">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-412">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-413">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-413">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-414">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-414">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-415">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-415">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-416">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-416">Random Mode</span></span>  
 <span data-ttu-id="46b80-417">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-417">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-418">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-418">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-419">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-419">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-420">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-420">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-421">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-421">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-422">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-422">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-423">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-423">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-424">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-424">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-425">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-425">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-426">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-426">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-427">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-427">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-428">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-428">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-429">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-429">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-430">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-430">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-431">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-431">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-432">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-432">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-433">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-433">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-434">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-434">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-435">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-435">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-436">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-436">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-437">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-437">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-438">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-438">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-439">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-439">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-440">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-440">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-441">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-441">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-442">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-442">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-443">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-443">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-444">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-444">Binary Mode</span></span>  
 <span data-ttu-id="46b80-445">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-445">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-446">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-446">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-447">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-447">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-448">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-448">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-449">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-449">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-450">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-450">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-451">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-451">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-452">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-452">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-453">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-453">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-454"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-454"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-455">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-455">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-456">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-456">Required.</span></span> <span data-ttu-id="46b80-457">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-457">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-458">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-458">Required.</span></span> <span data-ttu-id="46b80-459">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-459">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-460">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-460">Optional.</span></span> <span data-ttu-id="46b80-461">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-461">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-462">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-462">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-463">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-463">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-464">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-464">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-465">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-465">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-466">数据读取`FileGet`通常写入到的文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-466">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-467">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-467">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-468">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-468">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-469">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-469">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-470">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-470">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-471">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-471">Random Mode</span></span>  
 <span data-ttu-id="46b80-472">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-472">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-473">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-473">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-474">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-474">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-475">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-475">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-476">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-476">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-477">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-477">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-478">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-478">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-479">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-479">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-480">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-480">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-481">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-481">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-482">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-482">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-483">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-483">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-484">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-484">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-485">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-485">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-486">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-486">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-487">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-487">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-488">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-488">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-489">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-489">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-490">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-490">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-491">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-491">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-492">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-492">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-493">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-493">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-494">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-494">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-495">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-495">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-496">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-496">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-497">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-497">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-498">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-498">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-499">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-499">Binary Mode</span></span>  
 <span data-ttu-id="46b80-500">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-500">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-501">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-501">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-502">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-502">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-503">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-503">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-504">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-504">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-505">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-505">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-506">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-506">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-507">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-507">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-508">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-508">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-509"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-509"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-510">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-510">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-511">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-511">Required.</span></span> <span data-ttu-id="46b80-512">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-512">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-513">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-513">Required.</span></span> <span data-ttu-id="46b80-514">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-514">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-515">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-515">Optional.</span></span> <span data-ttu-id="46b80-516">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-516">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-517">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-517">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-518">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-518">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-519">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-519">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-520">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-520">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-521">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-521">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-522">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-522">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-523">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-523">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-524">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-524">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-525">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-525">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-526">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-526">Random Mode</span></span>  
 <span data-ttu-id="46b80-527">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-527">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-528">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-528">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-529">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-529">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-530">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-530">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-531">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-531">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-532">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-532">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-533">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-533">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-534">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-534">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-535">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-535">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-536">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-536">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-537">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-537">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-538">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-538">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-539">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-539">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-540">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-540">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-541">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-541">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-542">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-542">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-543">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-543">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-544">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-544">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-545">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-545">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-546">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-546">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-547">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-547">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-548">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-548">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-549">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-549">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-550">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-550">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-551">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-551">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-552">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-552">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-553">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-553">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-554">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-554">Binary Mode</span></span>  
 <span data-ttu-id="46b80-555">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-555">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-556">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-556">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-557">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-557">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-558">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-558">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-559">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-559">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-560">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-560">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-561">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-561">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-562">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-562">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-563">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-563">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-564"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-564"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-565">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-565">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-566">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-566">Required.</span></span> <span data-ttu-id="46b80-567">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-567">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-568">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-568">Required.</span></span> <span data-ttu-id="46b80-569">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-569">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-570">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-570">Optional.</span></span> <span data-ttu-id="46b80-571">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-571">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-572">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-572">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-573">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-573">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-574">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-574">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-575">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-575">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-576">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-576">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-577">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-577">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-578">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-578">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-579">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-579">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-580">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-580">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-581">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-581">Random Mode</span></span>  
 <span data-ttu-id="46b80-582">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-582">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-583">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-583">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-584">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-584">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-585">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-585">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-586">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-586">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-587">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-587">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-588">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-588">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-589">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-589">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-590">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-590">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-591">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-591">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-592">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-592">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-593">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-593">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-594">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-594">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-595">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-595">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-596">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-596">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-597">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-597">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-598">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-598">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-599">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-599">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-600">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-600">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-601">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-601">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-602">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-602">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-603">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-603">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-604">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-604">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-605">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-605">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-606">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-606">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-607">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-607">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-608">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-608">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-609">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-609">Binary Mode</span></span>  
 <span data-ttu-id="46b80-610">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-610">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-611">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-611">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-612">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-612">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-613">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-613">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-614">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-614">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-615">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-615">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-616">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-616">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-617">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-617">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-618">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-618">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-619"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-619"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-620">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-620">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-621">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-621">Required.</span></span> <span data-ttu-id="46b80-622">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-622">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-623">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-623">Required.</span></span> <span data-ttu-id="46b80-624">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-624">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-625">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-625">Optional.</span></span> <span data-ttu-id="46b80-626">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-626">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-627">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-627">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-628">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-628">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-629">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-629">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-630">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-630">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-631">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-631">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-632">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-632">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-633">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-633">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-634">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-634">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-635">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-635">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-636">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-636">Random Mode</span></span>  
 <span data-ttu-id="46b80-637">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-637">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-638">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-638">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-639">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-639">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-640">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-640">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-641">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-641">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-642">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-642">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-643">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-643">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-644">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-644">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-645">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-645">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-646">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-646">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-647">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-647">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-648">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-648">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-649">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-649">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-650">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-650">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-651">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-651">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-652">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-652">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-653">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-653">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-654">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-654">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-655">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-655">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-656">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-656">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-657">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-657">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-658">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-658">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-659">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-659">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-660">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-660">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-661">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-661">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-662">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-662">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-663">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-663">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-664">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-664">Binary Mode</span></span>  
 <span data-ttu-id="46b80-665">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-665">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-666">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-666">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-667">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-667">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-668">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-668">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-669">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-669">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-670">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-670">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-671">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-671">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-672">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-672">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-673">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-673">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-674"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-674"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-675">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-675">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-676">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-676">Required.</span></span> <span data-ttu-id="46b80-677">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-677">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-678">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-678">Required.</span></span> <span data-ttu-id="46b80-679">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-679">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-680">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-680">Optional.</span></span> <span data-ttu-id="46b80-681">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-681">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-682">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-682">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-683">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-683">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-684">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-684">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-685">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-685">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-686">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-686">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-687">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-687">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-688">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-688">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-689">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-689">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-690">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-690">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-691">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-691">Random Mode</span></span>  
 <span data-ttu-id="46b80-692">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-692">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-693">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-693">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-694">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-694">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-695">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-695">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-696">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-696">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-697">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-697">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-698">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-698">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-699">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-699">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-700">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-700">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-701">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-701">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-702">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-702">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-703">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-703">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-704">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-704">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-705">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-705">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-706">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-706">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-707">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-707">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-708">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-708">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-709">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-709">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-710">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-710">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-711">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-711">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-712">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-712">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-713">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-713">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-714">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-714">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-715">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-715">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-716">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-716">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-717">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-717">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-718">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-718">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-719">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-719">Binary Mode</span></span>  
 <span data-ttu-id="46b80-720">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-720">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-721">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-721">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-722">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-722">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-723">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-723">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-724">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-724">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-725">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-725">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-726">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-726">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-727">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-727">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-728">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-728">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-729"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-729"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-730">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-730">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-731">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-731">Required.</span></span> <span data-ttu-id="46b80-732">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-732">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-733">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-733">Required.</span></span> <span data-ttu-id="46b80-734">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-734">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-735">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-735">Optional.</span></span> <span data-ttu-id="46b80-736">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-736">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-737">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-737">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-738">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-738">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-739">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-739">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-740">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-740">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-741">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-741">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-742">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-742">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-743">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-743">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-744">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-744">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-745">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-745">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-746">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-746">Random Mode</span></span>  
 <span data-ttu-id="46b80-747">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-747">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-748">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-748">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-749">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-749">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-750">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-750">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-751">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-751">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-752">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-752">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-753">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-753">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-754">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-754">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-755">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-755">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-756">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-756">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-757">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-757">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-758">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-758">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-759">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-759">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-760">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-760">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-761">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-761">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-762">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-762">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-763">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-763">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-764">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-764">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-765">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-765">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-766">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-766">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-767">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-767">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-768">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-768">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-769">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-769">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-770">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-770">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-771">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-771">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-772">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-772">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-773">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-773">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-774">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-774">Binary Mode</span></span>  
 <span data-ttu-id="46b80-775">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-775">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-776">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-776">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-777">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-777">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-778">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-778">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-779">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-779">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-780">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-780">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-781">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-781">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-782">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-782">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-783">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-783">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-784"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-784"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-785">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-785">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-786">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-786">Required.</span></span> <span data-ttu-id="46b80-787">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-787">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-788">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-788">Required.</span></span> <span data-ttu-id="46b80-789">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-789">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-790">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-790">Optional.</span></span> <span data-ttu-id="46b80-791">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-791">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-792">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-792">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-793">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-793">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-794">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-794">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-795">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-795">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-796">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-796">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-797">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-797">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-798">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-798">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-799">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-799">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-800">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-800">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-801">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-801">Random Mode</span></span>  
 <span data-ttu-id="46b80-802">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-802">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-803">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-803">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-804">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-804">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-805">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-805">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-806">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-806">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-807">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-807">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-808">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-808">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-809">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-809">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-810">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-810">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-811">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-811">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-812">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-812">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-813">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-813">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-814">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-814">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-815">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-815">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-816">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-816">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-817">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-817">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-818">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-818">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-819">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-819">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-820">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-820">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-821">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-821">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-822">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-822">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-823">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-823">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-824">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-824">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-825">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-825">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-826">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-826">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-827">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-827">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-828">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-828">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-829">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-829">Binary Mode</span></span>  
 <span data-ttu-id="46b80-830">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-830">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-831">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-831">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-832">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-832">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-833">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-833">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-834">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-834">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-835">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-835">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-836">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-836">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-837">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-837">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-838">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-838">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-839"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-839"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-840">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-840">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-841">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-841">Required.</span></span> <span data-ttu-id="46b80-842">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-842">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-843">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-843">Required.</span></span> <span data-ttu-id="46b80-844">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-844">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-845">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-845">Optional.</span></span> <span data-ttu-id="46b80-846">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-846">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-847">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-847">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-848">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-848">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-849">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-849">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-850">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-850">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-851">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-851">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-852">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-852">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-853">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-853">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-854">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-854">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-855">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-855">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-856">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-856">Random Mode</span></span>  
 <span data-ttu-id="46b80-857">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-857">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-858">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-858">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-859">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-859">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-860">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-860">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-861">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-861">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-862">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-862">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-863">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-863">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-864">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-864">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-865">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-865">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-866">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-866">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-867">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-867">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-868">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-868">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-869">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-869">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-870">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-870">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-871">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-871">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-872">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-872">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-873">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-873">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-874">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-874">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-875">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-875">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-876">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-876">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-877">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-877">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-878">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-878">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-879">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-879">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-880">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-880">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-881">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-881">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-882">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-882">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-883">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-883">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-884">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-884">Binary Mode</span></span>  
 <span data-ttu-id="46b80-885">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-885">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-886">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-886">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-887">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-887">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-888">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-888">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-889">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-889">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-890">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-890">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-891">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-891">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-892">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-892">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-893">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-893">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-894"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-894"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-895">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-895">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-896">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-896">Required.</span></span> <span data-ttu-id="46b80-897">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-897">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-898">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-898">Required.</span></span> <span data-ttu-id="46b80-899">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-899">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-900">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-900">Optional.</span></span> <span data-ttu-id="46b80-901">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-901">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="46b80-902">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-902">Optional.</span></span> <span data-ttu-id="46b80-903">仅在写入字符串时适用。</span><span class="sxs-lookup"><span data-stu-id="46b80-903">Applies only when writing a string.</span></span> <span data-ttu-id="46b80-904">指定是否为描述长度的字符串写入一个双字节说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-904">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="46b80-905">默认值为 <see langword="False" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-905">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="46b80-906">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-906">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-907">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-907">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-908">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-908">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-909">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-909">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-910">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-910">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-911">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-911">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-912">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-912">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-913">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-913">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-914">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-914">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-915">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-915">Random Mode</span></span>  
 <span data-ttu-id="46b80-916">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-916">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-917">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-917">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-918">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-918">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-919">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-919">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-920">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-920">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-921">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-921">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-922">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-922">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-923">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-923">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-924">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-924">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-925">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-925">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-926">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-926">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-927">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-927">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-928">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-928">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-929">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-929">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-930">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-930">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-931">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-931">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-932">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-932">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-933">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-933">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-934">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-934">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-935">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-935">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-936">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-936">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-937">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-937">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-938">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-938">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-939">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-939">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-940">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-940">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-941">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-941">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-942">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-942">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-943">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-943">Binary Mode</span></span>  
 <span data-ttu-id="46b80-944">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-944">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-945">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-945">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-946">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-946">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-947">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-947">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-948">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-948">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-949">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-949">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-950">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-950">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-951">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-951">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-952">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-952">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-953"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-953"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-954">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-954">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-955">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-955">Required.</span></span> <span data-ttu-id="46b80-956">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-956">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-957">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-957">Required.</span></span> <span data-ttu-id="46b80-958">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-958">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-959">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-959">Optional.</span></span> <span data-ttu-id="46b80-960">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-960">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="46b80-961">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-961">Optional.</span></span> <span data-ttu-id="46b80-962">仅当写入数组时使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-962">Applies only when writing an array.</span></span> <span data-ttu-id="46b80-963">指定是否将数组视为动态数组，以及是否需要描述数组大小和边界的数组说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-963">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="46b80-964">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-964">Optional.</span></span> <span data-ttu-id="46b80-965">仅在写入字符串时适用。</span><span class="sxs-lookup"><span data-stu-id="46b80-965">Applies only when writing a string.</span></span> <span data-ttu-id="46b80-966">指定是否为描述长度的字符串写入一个双字节说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-966">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="46b80-967">默认值为 <see langword="False" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-967">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="46b80-968">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-968">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="46b80-969">相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-969">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="46b80-970">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-970">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-971">`FileGet` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-971">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-972">数据读取`FileGet`通过使用通常写入到文件`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-972">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="46b80-973">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-973">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-974">如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向由最后一个`Seek`函数) 读取。</span><span class="sxs-lookup"><span data-stu-id="46b80-974">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-975">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-975">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-976">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-976">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-977">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-977">Random Mode</span></span>  
 <span data-ttu-id="46b80-978">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-978">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-979">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-979">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-980">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-980">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-981">因为无法任何明确地确定填充的数据量，它通常是具有匹配的数据被读取的长度的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-981">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-982">默认情况下，如果读入的变量是一个字符串，`FileGet`读取包含字符串长度，然后读放入变量的数据的两个字节描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-982">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-983">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-983">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-984">Visual Basic 6.0 和早期版本支持的固定长度字符串;当放到文件，则不写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-984">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-985">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-985">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-986">如果读入的变量是一个数组，你可以选择是否要读取的大小和数组的维度属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-986">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="46b80-987">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-987">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-988">在读取数组时，必须以匹配写入数组的方式。</span><span class="sxs-lookup"><span data-stu-id="46b80-988">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="46b80-989">如果它使用描述符编写的必须读取描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-989">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="46b80-990">如果不使用说明符的大小和数组的边界传递给`FileGet`确定要读取的内容。</span><span class="sxs-lookup"><span data-stu-id="46b80-990">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="46b80-991">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-991">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-992">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-992">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-993">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-993">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-994">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-994">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="46b80-995">分发了 218 个字节，如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-995">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="46b80-996">描述符 18 个字节: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="46b80-996">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="46b80-997">200 字节的数据: (5 * 10 * 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-997">200 bytes for the data: (5 * 10 * 4).</span></span>  
  
-   <span data-ttu-id="46b80-998">如果读入变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`读取仅变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-998">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="46b80-999">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于所读取的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-999">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-1000">`FileGet` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-1000">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-1001">在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1001">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1002">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1002">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="46b80-1003">这包括任何数组和其描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1003">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-1004">`VBFixedString`特性可以应用于以指示时写入字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1004">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1005">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1005">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1006">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1006">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1007">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1007">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1008">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1008">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1009">`FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1009">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1010">对于在结构中，数组以外的任何数组`FileGet`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1010">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="46b80-1011">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1011">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="46b80-1012">`FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1012">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1013">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1013">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="46b80-1014">通过使用从文件读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1014">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1015"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1015"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1016">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1016">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1017">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1017">Required.</span></span> <span data-ttu-id="46b80-1018">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1018">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1019">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1019">Required.</span></span> <span data-ttu-id="46b80-1020">数据读入到其中的有效变量名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-1020">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1021">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1021">Optional.</span></span> <span data-ttu-id="46b80-1022">读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1022">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1023">将数据从打开的磁盘文件读入到一个变量中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1023">Reads data from an open disk file into a variable.</span></span>  <span data-ttu-id="46b80-1024">相比 <see langword="FileGetObject" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1024">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span></span> <span data-ttu-id="46b80-1025">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1025">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1026">`FileGetObject`而不是使用函数`FileGet`以避免多义性在编译时，如果类型`Object`会返回而不是另一个类型，如`Integer`， `Long`， `Short`，依次类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1026">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="46b80-1027">如果你想要写出`Variant`类型，`FileGetObject`是必需的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1027">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="46b80-1028">当有疑问时，如果第二个参数使用一个对象，它始终建议你使用`FilePutObject`和`FileGetObject`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1028">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="46b80-1029">`FileGetObject` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1029">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1030">数据读取`FileGetObject`通常使用编写`FilePutObject`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1030">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="46b80-1031">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1031">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1032">如果省略`RecordNumber`，`FileGetObject`上次读取的记录或字节`FileGetObject`或`FilePutObject`函数 (或指向由最后一个`Seek`函数)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1032">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1033">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1033">Random Mode</span></span>  
 <span data-ttu-id="46b80-1034">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1034">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1035">如果正在读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGetObject`读取的记录长度边界上的后续记录。</span><span class="sxs-lookup"><span data-stu-id="46b80-1035">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1036">将文件缓冲区的现有内容，则填充一个记录的结尾和开头的下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1036">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1037">因为无法精确地确定填充的数据量，最好具有匹配的数据被读取的长度的记录长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1037">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="46b80-1038">如果读入的变量是一个字符串，默认情况下的`FileGetObject`读取包含字符串长度的两个字节描述符，然后读取放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1038">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1039">因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1039">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1040">Visual Basic 6.0 和早期版本支持固定长度字符串和读取到文件时，则不会写入长度描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1040">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="46b80-1041">如果你想要读取的字符串没有说明符，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1041">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1042">如果读入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 参数指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1042">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1043">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1043">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1044">其长度等于 2 + 8 时间维度数： 2 + 8 \* NumberOfDimensions。</span><span class="sxs-lookup"><span data-stu-id="46b80-1044">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="46b80-1045">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘：</span><span class="sxs-lookup"><span data-stu-id="46b80-1045">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="46b80-1046">分发了 218 个字节，如下所示：为描述符分发了 18 个字节 (2 + 8 \* 2)，为数据分发了 100 个字节 (5 \* 10 \* 4)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1046">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="46b80-1047">`FileGetObject` 中读取结构的元素，每个已分别读取的只不过没有元素之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-1047">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="46b80-1048">在磁盘上，用户定义类型的动态数组 (使用编写`FilePutObject`) 通过其长度等于 2 加上 8 倍维度数的描述符的前缀： 2 + 8 \* NumberOfDimensions。</span><span class="sxs-lookup"><span data-stu-id="46b80-1048">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="46b80-1049">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于进行读取的各个元素，包括任何数组和其描述符所需的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1049">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="46b80-1050"><xref:Microsoft.VisualBasic.VBFixedStringAttribute>类可以应用于以指示字符串写入时的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1050">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1051">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1051">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1052">打开的文件中`Binary`模式下，所有的`Random`规则适用，但存在下列例外：</span><span class="sxs-lookup"><span data-stu-id="46b80-1052">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="46b80-1053">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1053">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1054">`FileGetObject` 读取所有变量从磁盘连续，即记录之间没有空白。</span><span class="sxs-lookup"><span data-stu-id="46b80-1054">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1055">对于在结构中，数组以外的任何数组`FileGetObject`的只读取数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1055">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="46b80-1056">未不读取任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1056">No descriptor is read.</span></span>  
  
 <span data-ttu-id="46b80-1057">`FileGetObject` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1057">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1058">读取的字节数等于已在字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1058">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-1059">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-1059">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-1060">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1060">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1061">下面的示例读入测试文件中读取一条记录，然后检索它。</span><span class="sxs-lookup"><span data-stu-id="46b80-1061">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="46b80-1062">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1062">Required.</span></span> <span data-ttu-id="46b80-1063"><see langword="String" /> 表达式，用于指定文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1063"><see langword="String" /> expression that specifies a file.</span></span> <span data-ttu-id="46b80-1064"><c>PathName</c> 可以包含目录或文件夹以及驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-1064"><c>PathName</c> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="46b80-1065">返回 <see langword="Long" /> 值，该值以字节为单位指定文件长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1065">Returns a <see langword="Long" /> value that specifies the length of a file in bytes.</span></span> <span data-ttu-id="46b80-1066">相比 <see langword="FileLen" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1066">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span></span> <span data-ttu-id="46b80-1067">有关详情，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1067">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span></span></summary>
        <returns>
          <span data-ttu-id="46b80-1068"><see langword="Long" /> 值，该值以字节为单位指定文件长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1068"><see langword="Long" /> value that specifies the length of a file in bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1069">如果指定的文件打开时`FileLen`被调用函数时，它已打开时，返回的值表示文件的大小。</span><span class="sxs-lookup"><span data-stu-id="46b80-1069">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-1070">若要获取的当前打开的文件的长度，请使用`LOF`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1070">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1071">此示例使用`FileLen`函数以返回文件的长度以字节为单位。</span><span class="sxs-lookup"><span data-stu-id="46b80-1071">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="46b80-1072">在此示例中，假定`TestFile`是包含一些数据的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1072">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="46b80-1073">文件不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-1073">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1074">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1074">Required.</span></span> <span data-ttu-id="46b80-1075">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1075">Any valid file number.</span></span> <span data-ttu-id="46b80-1076">可使用 <see langword="FreeFile" /> 函数获取下一个可用的文件号。</span><span class="sxs-lookup"><span data-stu-id="46b80-1076">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span></span></param>
        <param name="FileName"><span data-ttu-id="46b80-1077">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1077">Required.</span></span> <span data-ttu-id="46b80-1078">一个指定文件名的 <see langword="String" /> 表达式，其中可包含目录或文件夹以及驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-1078"><see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</span></span></param>
        <param name="Mode"><span data-ttu-id="46b80-1079">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1079">Required.</span></span> <span data-ttu-id="46b80-1080">指定文件模式的枚举：<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" /> 或 <see langword="Random" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1080">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span></span> <span data-ttu-id="46b80-1081">有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.OpenMode" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1081">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span></span></param>
        <param name="Access"><span data-ttu-id="46b80-1082">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1082">Optional.</span></span> <span data-ttu-id="46b80-1083">一个枚举，它指定对打开的文件所允许进行的操作：<see langword="Read" />、<see langword="Write" /> 或 <see langword="ReadWrite" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1083">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span></span> <span data-ttu-id="46b80-1084">默认为 <see langword="ReadWrite" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1084">Defaults to <see langword="ReadWrite" />.</span></span> <span data-ttu-id="46b80-1085">有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.OpenAccess" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1085">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span></span></param>
        <param name="Share"><span data-ttu-id="46b80-1086">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1086">Optional.</span></span> <span data-ttu-id="46b80-1087">一个枚举，它指定不允许其他进程对打开的文件所进行的操作：<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" /> 和 <see langword="Lock Read Write" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1087">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="46b80-1088">默认为 <see langword="Lock Read Write" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1088">Defaults to <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="46b80-1089">有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.OpenShare" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1089">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span></span></param>
        <param name="RecordLength"><span data-ttu-id="46b80-1090">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1090">Optional.</span></span> <span data-ttu-id="46b80-1091">小于或等于 32,767（字节）的数字。</span><span class="sxs-lookup"><span data-stu-id="46b80-1091">Number less than or equal to 32,767 (bytes).</span></span> <span data-ttu-id="46b80-1092">对于为进行随机访问而打开的文件，此值是记录的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1092">For files opened for random access, this value is the record length.</span></span> <span data-ttu-id="46b80-1093">对于顺序文件，此值是缓冲的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1093">For sequential files, this value is the number of characters buffered.</span></span></param>
        <summary><span data-ttu-id="46b80-1094">打开一个文件以进行输入或输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-1094">Opens a file for input or output.</span></span> <span data-ttu-id="46b80-1095">相比 <see langword="FileOpen" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1095">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span></span> <span data-ttu-id="46b80-1096">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1096">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1097">`FileOpen`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-1097">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-1098">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-1098">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-1099">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1099">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-1100">可以对其执行任何 I/O 操作之前，必须打开文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1100">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="46b80-1101">`FileOpen` 针对 I/O 分配缓冲区，文件并确定要用于缓冲区的访问模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1101">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-1102">写入到文件时，应用程序可能需要创建一个文件，如果尝试写入的文件不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-1102">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="46b80-1103">为此，它将用用于创建文件的目录中需要的权限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1103">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="46b80-1104">但是，如果指定的文件`FileName`确实存在，应用程序需求`Write`仅指向文件本身的权限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1104">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="46b80-1105">可能有助于提高安全性，部署和授予期间创建文件的任何位置`Write`对该文件的权限仅，而不是整个目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-1105">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="46b80-1106">为了提高安全性，请将数据写入到的根目录或 Program Files 目录的用户目录而不是。</span><span class="sxs-lookup"><span data-stu-id="46b80-1106">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="46b80-1107">若要打开的通道可通过使用找到`FreeFile()`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1107">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-1108">`FileOpen`函数需要`Read`从访问`FileIOPermissionAccess`枚举，从而可能影响在部分信任情况下其执行。</span><span class="sxs-lookup"><span data-stu-id="46b80-1108">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="46b80-1109">有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-1109">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1110">此示例演示如何的各种用法`FileOpen`函数，以使输入和输出到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1110">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="46b80-1111">下面的代码中打开的文件`TestFile`中`Input`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1111">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="46b80-1112">此示例打开中的文件`Binary`进行只写操作的模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1112">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="46b80-1113">下面的示例打开中的文件`Random`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1113">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="46b80-1114">该文件包含的记录是结构`Person`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1114">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="46b80-1115">此代码示例将打开的文件中`Output`模式; 任何进程可以读取或写入文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1115">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="46b80-1116">此代码示例将打开的文件中`Binary`模式供读取，则其他进程无法读取文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1116">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="46b80-1117">记录长度是负数（并且不等于 -1）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1117">Record length is negative (and not equal to -1).</span></span></exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="46b80-1118"><paramref name="FileName" /> 已经打开，或 <paramref name="FileName" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1118"><paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-1119">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1119">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1120">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1120">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1121">有关更多信息，请参见 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1121">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1122">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1122">Required.</span></span> <span data-ttu-id="46b80-1123">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1123">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1124">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1124">Required.</span></span> <span data-ttu-id="46b80-1125">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1125">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1126">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1126">Optional.</span></span> <span data-ttu-id="46b80-1127">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1127">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1128">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1128">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1129">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1129">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1130">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1130">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1131">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1131">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1132">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1132">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1133">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1133">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1134">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1134">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1135">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1135">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1136">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1136">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1137">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1137">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1138">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1138">Random Mode</span></span>  
 <span data-ttu-id="46b80-1139">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1139">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1140">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1140">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1141">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1141">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1142">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1142">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1143">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1143">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1144">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1144">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1145">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1145">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1146">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1146">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1147">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1147">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1148">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1148">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1149">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1149">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1150">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1150">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1151">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1151">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1152">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1152">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1153">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1153">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1154">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1154">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1155">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1155">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1156">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1156">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1157">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1157">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1158">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1158">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1159">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1159">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1160">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1160">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1161">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1161">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1162">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1162">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1163">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1163">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1164">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1164">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1165">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1165">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1166">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1166">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1167">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1167">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1168">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1168">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1169">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1169">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1170">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1170">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1171">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1171">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1172">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1172">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1173">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1173">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1174">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1174">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1175">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1175">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1176">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1176">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1177">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1177">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1178">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1178">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1179"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1179"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1180">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1180">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1181">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1181">Required.</span></span> <span data-ttu-id="46b80-1182">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1182">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1183">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1183">Required.</span></span> <span data-ttu-id="46b80-1184">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1184">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1185">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1185">Optional.</span></span> <span data-ttu-id="46b80-1186">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1186">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1187">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1187">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1188">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1188">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1189">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1189">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1190">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1190">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1191">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1191">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1192">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1192">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1193">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1193">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1194">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1194">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1195">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1195">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1196">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1196">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1197">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1197">Random Mode</span></span>  
 <span data-ttu-id="46b80-1198">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1198">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1199">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1199">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1200">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1200">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1201">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1201">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1202">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1202">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1203">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1203">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1204">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1204">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1205">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1205">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1206">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1206">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1207">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1207">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1208">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1208">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1209">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1209">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1210">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1210">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1211">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1211">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1212">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1212">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1213">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1213">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1214">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1214">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1215">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1215">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1216">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1216">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1217">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1217">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1218">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1218">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1219">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1219">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1220">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1220">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1221">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1221">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1222">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1222">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1223">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1223">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1224">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1224">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1225">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1225">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1226">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1226">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1227">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1227">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1228">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1228">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1229">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1229">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1230">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1230">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1231">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1231">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1232">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1232">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1233">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1233">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1234">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1234">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1235">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1235">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1236">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1236">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1237">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1237">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1238"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1238"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1239">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1239">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1240">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1240">Required.</span></span> <span data-ttu-id="46b80-1241">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1241">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1242">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1242">Required.</span></span> <span data-ttu-id="46b80-1243">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1243">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1244">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1244">Optional.</span></span> <span data-ttu-id="46b80-1245">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1245">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1246">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1246">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1247">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1247">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1248">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1248">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1249">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1249">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1250">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1250">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1251">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1251">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1252">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1252">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1253">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1253">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1254">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1254">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1255">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1255">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1256">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1256">Random Mode</span></span>  
 <span data-ttu-id="46b80-1257">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1257">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1258">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1258">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1259">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1259">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1260">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1260">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1261">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1261">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1262">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1262">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1263">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1263">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1264">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1264">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1265">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1265">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1266">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1266">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1267">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1267">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1268">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1268">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1269">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1269">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1270">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1270">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1271">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1271">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1272">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1272">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1273">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1273">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1274">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1274">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1275">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1275">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1276">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1276">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1277">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1277">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1278">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1278">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1279">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1279">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1280">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1280">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1281">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1281">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1282">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1282">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1283">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1283">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1284">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1284">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1285">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1285">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1286">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1286">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1287">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1287">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1288">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1288">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1289">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1289">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1290">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1290">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1291">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1291">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1292">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1292">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1293">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1293">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1294">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1294">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1295">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1295">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1296">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1296">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1297"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1297"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1298">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1298">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1299">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1299">Required.</span></span> <span data-ttu-id="46b80-1300">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1300">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1301">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1301">Required.</span></span> <span data-ttu-id="46b80-1302">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1302">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1303">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1303">Optional.</span></span> <span data-ttu-id="46b80-1304">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1304">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1305">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1305">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1306">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1306">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1307">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1307">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1308">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1308">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1309">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1309">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1310">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1310">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1311">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1311">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1312">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1312">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1313">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1313">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1314">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1314">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1315">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1315">Random Mode</span></span>  
 <span data-ttu-id="46b80-1316">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1316">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1317">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1317">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1318">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1318">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1319">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1319">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1320">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1320">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1321">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1321">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1322">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1322">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1323">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1323">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1324">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1324">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1325">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1325">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1326">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1326">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1327">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1327">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1328">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1328">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1329">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1329">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1330">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1330">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1331">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1331">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1332">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1332">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1333">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1333">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1334">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1334">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1335">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1335">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1336">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1336">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1337">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1337">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1338">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1338">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1339">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1339">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1340">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1340">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1341">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1341">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1342">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1342">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1343">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1343">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1344">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1344">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1345">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1345">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1346">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1346">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1347">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1347">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1348">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1348">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1349">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1349">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1350">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1350">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1351">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1351">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1352">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1352">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1353">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1353">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1354">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1354">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1355">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1355">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1356"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1356"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1357">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1357">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1358">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1358">Required.</span></span> <span data-ttu-id="46b80-1359">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1359">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1360">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1360">Required.</span></span> <span data-ttu-id="46b80-1361">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1361">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1362">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1362">Optional.</span></span> <span data-ttu-id="46b80-1363">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1363">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1364">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1364">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1365">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1365">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1366">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1366">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1367">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1367">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1368">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1368">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1369">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1369">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1370">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1370">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1371">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1371">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1372">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1372">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1373">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1373">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1374">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1374">Random Mode</span></span>  
 <span data-ttu-id="46b80-1375">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1375">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1376">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1376">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1377">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1377">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1378">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1378">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1379">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1379">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1380">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1380">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1381">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1381">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1382">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1382">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1383">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1383">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1384">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1384">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1385">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1385">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1386">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1386">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1387">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1387">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1388">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1388">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1389">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1389">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1390">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1390">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1391">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1391">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1392">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1392">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1393">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1393">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1394">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1394">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1395">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1395">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1396">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1396">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1397">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1397">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1398">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1398">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1399">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1399">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1400">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1400">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1401">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1401">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1402">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1402">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1403">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1403">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1404">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1404">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1405">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1405">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1406">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1406">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1407">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1407">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1408">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1408">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1409">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1409">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1410">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1410">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1411">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1411">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1412">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1412">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1413">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1413">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1414">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1414">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1415"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1415"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1416">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1416">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1417">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1417">Required.</span></span> <span data-ttu-id="46b80-1418">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1418">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1419">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1419">Required.</span></span> <span data-ttu-id="46b80-1420">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1420">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1421">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1421">Optional.</span></span> <span data-ttu-id="46b80-1422">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1422">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1423">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1423">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1424">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1424">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1425">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1425">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1426">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1426">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1427">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1427">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1428">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1428">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1429">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1429">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1430">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1430">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1431">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1431">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1432">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1432">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1433">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1433">Random Mode</span></span>  
 <span data-ttu-id="46b80-1434">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1434">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1435">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1435">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1436">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1436">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1437">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1437">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1438">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1438">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1439">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1439">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1440">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1440">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1441">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1441">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1442">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1442">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1443">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1443">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1444">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1444">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1445">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1445">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1446">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1446">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1447">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1447">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1448">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1448">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1449">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1449">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1450">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1450">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1451">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1451">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1452">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1452">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1453">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1453">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1454">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1454">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1455">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1455">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1456">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1456">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1457">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1457">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1458">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1458">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1459">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1459">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1460">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1460">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1461">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1461">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1462">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1462">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1463">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1463">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1464">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1464">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1465">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1465">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1466">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1466">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1467">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1467">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1468">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1468">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1469">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1469">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1470">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1470">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1471">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1471">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1472">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1472">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1473">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1473">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1474"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1474"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1475">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1475">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1476">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1476">Required.</span></span> <span data-ttu-id="46b80-1477">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1477">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1478">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1478">Required.</span></span> <span data-ttu-id="46b80-1479">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1479">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1480">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1480">Optional.</span></span> <span data-ttu-id="46b80-1481">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1481">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1482">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1482">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1483">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1483">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1484">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1484">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1485">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1485">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1486">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1486">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1487">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1487">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1488">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1488">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1489">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1489">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1490">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1490">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1491">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1491">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1492">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1492">Random Mode</span></span>  
 <span data-ttu-id="46b80-1493">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1493">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1494">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1494">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1495">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1495">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1496">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1496">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1497">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1497">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1498">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1498">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1499">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1499">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1500">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1500">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1501">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1501">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1502">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1502">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1503">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1503">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1504">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1504">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1505">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1505">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1506">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1506">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1507">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1507">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1508">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1508">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1509">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1509">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1510">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1510">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1511">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1511">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1512">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1512">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1513">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1513">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1514">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1514">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1515">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1515">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1516">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1516">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1517">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1517">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1518">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1518">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1519">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1519">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1520">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1520">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1521">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1521">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1522">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1522">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1523">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1523">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1524">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1524">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1525">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1525">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1526">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1526">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1527">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1527">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1528">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1528">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1529">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1529">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1530">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1530">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1531">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1531">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1532">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1532">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1533"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1533"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1534">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1534">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1535">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1535">Required.</span></span> <span data-ttu-id="46b80-1536">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1536">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1537">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1537">Required.</span></span> <span data-ttu-id="46b80-1538">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1538">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1539">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1539">Optional.</span></span> <span data-ttu-id="46b80-1540">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1540">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1541">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1541">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1542">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1542">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1543">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1543">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1544">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1544">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1545">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1545">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1546">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1546">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1547">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1547">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1548">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1548">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1549">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1549">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1550">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1550">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1551">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1551">Random Mode</span></span>  
 <span data-ttu-id="46b80-1552">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1552">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1553">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1553">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1554">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1554">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1555">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1555">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1556">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1556">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1557">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1557">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1558">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1558">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1559">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1559">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1560">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1560">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1561">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1561">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1562">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1562">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1563">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1563">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1564">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1564">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1565">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1565">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1566">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1566">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1567">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1567">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1568">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1568">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1569">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1569">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1570">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1570">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1571">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1571">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1572">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1572">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1573">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1573">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1574">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1574">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1575">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1575">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1576">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1576">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1577">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1577">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1578">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1578">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1579">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1579">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1580">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1580">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1581">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1581">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1582">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1582">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1583">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1583">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1584">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1584">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1585">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1585">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1586">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1586">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1587">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1587">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1588">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1588">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1589">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1589">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1590">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1590">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1591">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1591">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1592"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1592"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1593">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1593">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1594">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1594">Required.</span></span> <span data-ttu-id="46b80-1595">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1595">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1596">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1596">Required.</span></span> <span data-ttu-id="46b80-1597">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1597">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1598">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1598">Optional.</span></span> <span data-ttu-id="46b80-1599">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1599">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1600">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1600">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1601">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1601">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1602">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1602">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1603">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1603">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1604">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1604">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1605">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1605">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1606">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1606">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1607">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1607">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1608">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1608">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1609">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1609">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1610">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1610">Random Mode</span></span>  
 <span data-ttu-id="46b80-1611">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1611">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1612">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1612">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1613">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1613">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1614">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1614">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1615">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1615">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1616">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1616">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1617">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1617">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1618">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1618">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1619">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1619">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1620">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1620">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1621">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1621">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1622">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1622">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1623">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1623">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1624">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1624">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1625">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1625">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1626">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1626">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1627">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1627">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1628">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1628">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1629">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1629">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1630">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1630">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1631">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1631">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1632">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1632">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1633">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1633">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1634">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1634">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1635">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1635">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1636">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1636">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1637">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1637">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1638">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1638">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1639">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1639">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1640">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1640">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1641">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1641">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1642">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1642">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1643">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1643">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1644">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1644">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1645">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1645">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1646">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1646">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1647">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1647">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1648">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1648">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1649">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1649">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1650">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1650">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1651"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1651"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1652">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1652">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1653">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1653">Required.</span></span> <span data-ttu-id="46b80-1654">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1654">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1655">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1655">Required.</span></span> <span data-ttu-id="46b80-1656">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1656">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1657">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1657">Optional.</span></span> <span data-ttu-id="46b80-1658">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1658">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1659">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1659">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1660">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1660">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1661">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1661">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1662">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1662">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1663">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1663">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1664">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1664">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1665">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1665">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1666">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1666">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1667">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1667">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1668">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1668">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1669">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1669">Random Mode</span></span>  
 <span data-ttu-id="46b80-1670">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1670">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1671">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1671">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1672">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1672">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1673">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1673">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1674">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1674">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1675">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1675">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1676">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1676">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1677">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1677">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1678">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1678">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1679">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1679">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1680">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1680">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1681">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1681">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1682">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1682">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1683">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1683">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1684">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1684">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1685">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1685">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1686">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1686">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1687">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1687">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1688">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1688">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1689">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1689">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1690">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1690">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1691">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1691">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1692">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1692">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1693">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1693">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1694">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1694">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1695">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1695">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1696">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1696">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1697">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1697">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1698">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1698">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1699">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1699">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1700">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1700">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1701">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1701">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1702">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1702">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1703">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1703">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1704">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1704">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1705">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1705">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1706">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1706">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1707">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1707">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1708">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1708">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1709">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1709">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1710"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1710"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1711">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1711">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1712">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1712">Required.</span></span> <span data-ttu-id="46b80-1713">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1713">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1714">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1714">Required.</span></span> <span data-ttu-id="46b80-1715">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1715">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1716">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1716">Optional.</span></span> <span data-ttu-id="46b80-1717">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1717">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1718">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1718">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1719">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1719">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1720">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1720">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1721">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1721">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1722">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1722">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1723">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1723">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1724">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1724">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1725">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1725">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1726">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1726">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1727">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1727">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1728">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1728">Random Mode</span></span>  
 <span data-ttu-id="46b80-1729">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1729">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1730">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1730">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1731">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1731">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1732">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1732">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1733">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1733">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1734">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1734">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1735">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1735">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1736">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1736">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1737">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1737">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1738">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1738">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1739">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1739">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1740">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1740">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1741">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1741">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1742">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1742">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1743">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1743">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1744">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1744">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1745">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1745">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1746">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1746">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1747">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1747">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1748">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1748">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1749">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1749">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1750">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1750">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1751">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1751">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1752">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1752">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1753">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1753">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1754">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1754">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1755">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1755">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1756">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1756">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1757">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1757">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1758">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1758">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1759">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1759">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1760">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1760">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1761">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1761">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1762">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1762">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1763">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1763">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1764">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1764">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1765">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1765">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1766">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1766">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1767">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1767">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1768">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1768">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1769"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1769"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1770">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1770">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1771">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1771">Required.</span></span> <span data-ttu-id="46b80-1772">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1772">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1773">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1773">Required.</span></span> <span data-ttu-id="46b80-1774">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1774">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1775">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1775">Optional.</span></span> <span data-ttu-id="46b80-1776">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1776">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1777">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1777">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1778">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1778">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1779">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1779">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1780">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1780">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1781">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1781">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1782">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1782">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1783">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1783">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1784">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1784">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1785">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1785">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1786">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1786">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1787">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1787">Random Mode</span></span>  
 <span data-ttu-id="46b80-1788">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1788">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1789">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1789">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1790">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1790">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1791">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1791">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1792">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1792">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1793">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1793">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1794">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1794">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1795">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1795">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1796">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1796">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1797">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1797">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1798">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1798">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1799">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1799">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1800">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1800">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1801">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1801">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1802">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1802">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1803">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1803">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1804">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1804">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1805">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1805">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1806">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1806">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1807">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1807">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1808">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1808">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1809">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1809">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1810">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1810">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1811">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1811">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1812">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1812">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1813">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1813">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1814">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1814">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1815">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1815">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1816">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1816">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1817">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1817">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1818">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1818">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1819">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1819">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1820">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1820">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1821">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1821">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1822">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1822">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1823">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1823">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1824">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1824">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1825">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1825">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1826">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1826">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1827">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1827">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1828"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1828"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1829">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1829">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1830">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1830">Required.</span></span> <span data-ttu-id="46b80-1831">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1831">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1832">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1832">Required.</span></span> <span data-ttu-id="46b80-1833">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1833">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1834">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1834">Optional.</span></span> <span data-ttu-id="46b80-1835">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1835">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="46b80-1836">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1836">Optional.</span></span> <span data-ttu-id="46b80-1837">仅在写入字符串时适用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1837">Applies only when writing a string.</span></span> <span data-ttu-id="46b80-1838">指定是否将字符串的双字节字符串长度说明符写入文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1838">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="46b80-1839">默认值为 <see langword="False" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1839">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="46b80-1840">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1840">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1841">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1841">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1842">有关更多信息，请参见 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1842">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1843">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1843">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1844">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1844">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1845">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1845">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1846">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1846">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1847">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1847">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1848">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1848">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1849">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1849">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1850">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1850">Random Mode</span></span>  
 <span data-ttu-id="46b80-1851">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1851">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1852">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1852">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1853">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1853">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1854">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1854">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1855">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1855">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1856">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1856">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1857">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1857">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1858">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1858">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1859">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1859">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1860">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1860">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1861">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1861">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1862">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1862">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1863">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1863">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1864">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1864">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1865">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1865">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1866">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1866">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1867">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1867">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1868">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1868">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1869">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1869">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1870">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1870">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1871">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1871">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1872">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1872">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1873">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1873">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1874">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1874">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1875">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1875">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1876">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1876">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1877">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1877">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1878">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1878">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1879">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1879">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1880">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1880">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1881">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1881">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1882">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1882">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1883">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1883">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1884">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1884">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1885">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1885">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1886">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1886">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1887">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1887">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1888">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1888">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1889">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1889">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1890">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1890">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1891"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1891"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1892">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1892">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1893">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1893">Required.</span></span> <span data-ttu-id="46b80-1894">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1894">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1895">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1895">Required.</span></span> <span data-ttu-id="46b80-1896">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1896">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1897">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1897">Optional.</span></span> <span data-ttu-id="46b80-1898">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1898">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="46b80-1899">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1899">Optional.</span></span> <span data-ttu-id="46b80-1900">仅当写入数组时使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1900">Applies only when writing an array.</span></span> <span data-ttu-id="46b80-1901">指定是否将数组视为动态数组，以及是否写入用于描述字符串长度的数组说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1901">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="46b80-1902">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1902">Optional.</span></span> <span data-ttu-id="46b80-1903">仅在写入字符串时适用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1903">Applies only when writing a string.</span></span> <span data-ttu-id="46b80-1904">指定是否将字符串的双字节字符串长度说明符写入文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1904">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="46b80-1905">默认值为 <see langword="False" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1905">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="46b80-1906">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1906">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="46b80-1907">相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1907">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="46b80-1908">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1908">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1909">`FilePut` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1909">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1910">通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1910">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="46b80-1911">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1911">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1912">如果省略`RecordNumber`下, 一个记录或后的最后一个字节`FileGet`或`FilePut`函数或由最后一个指向`Seek`编写函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1912">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="46b80-1913">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1913">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1914">`FilePut` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1914">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1915">如果你使用`StringIsFixedLength`  =  `True`与`FilePut`，您需要做相同，但有`FileGet`，并且你必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1915">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1916">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1916">Random Mode</span></span>  
 <span data-ttu-id="46b80-1917">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1917">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1918">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1918">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1919">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1919">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1920">因为无法任何明确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1920">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1921">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1921">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1922">如果写入的变量是一个字符串，`FilePut`将写入两个字节说明符，包含了字符串长度，然后写入放入变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1922">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="46b80-1923">因此，指定的记录长度`RecordLength`中的子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1923">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="46b80-1924">写入的变量是否包含数值类型的对象`FilePut`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1924">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1925">例如，当编写一个对象时，包含一个整数，`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1925">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1926">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1926">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1927">如果写入的变量是一个对象，包含一个字符串，`FilePut`先写入两个字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1927">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1928">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1928">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1929">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1929">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1930">如果写入的变量是一个数组，则必须选择要写入的大小和数组的维度的属性的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1930">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="46b80-1931">Visual Basic 6.0 和早期版本编写的文件描述符为动态数组而不是固定大小的数组。</span><span class="sxs-lookup"><span data-stu-id="46b80-1931">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="46b80-1932">Visual Basic 2005 默认为不能写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1932">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="46b80-1933">若要编写描述符，设置`ArrayIsDynamic`参数`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1933">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="46b80-1934">当编写数组，你必须相匹配的方法将读取的数组;如果将具有描述符读取，你必须编写描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1934">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="46b80-1935">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1935">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1936">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1936">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="46b80-1937">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1937">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1938">例如，下面的数组声明需要 218 个字节时将数组写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1938">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="46b80-1939">如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`将变量的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1939">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="46b80-1940">指定的记录长度`RecordLength`中的子句`FileOpen`函数必须是大于或等于写入的数据的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1940">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="46b80-1941">`FilePut` 将元素的结构写入就像分别，写入的每个元素之间没有空白的情况除外。</span><span class="sxs-lookup"><span data-stu-id="46b80-1941">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="46b80-1942">`VBFixedString`特性可以应用于以指示写入的字符串的大小的结构中的 string 字段到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-1942">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="46b80-1943">字符串具有更多个字节，超过指定值的字段`VBFixedString`属性会被截断时写入到磁盘，</span><span class="sxs-lookup"><span data-stu-id="46b80-1943">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1944">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1944">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1945">打开的文件中`Binary`模式下，大部分`Random`模式规则适用，但出现一些异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1945">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="46b80-1946">在中打开文件的以下规则`Binary`模式与不同的规则`Random`模式：</span><span class="sxs-lookup"><span data-stu-id="46b80-1946">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="46b80-1947">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1947">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1948">`FilePut` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1948">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="46b80-1949">对于在结构中，数组以外的任何数组`FilePut`只写入数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1949">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="46b80-1950">未不写入任何说明符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1950">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="46b80-1951">`FilePut` 写入不是元素的结构没有两个字节长度说明符的可变长度字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1951">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="46b80-1952">写入的字节数等于字符串中的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1952">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="46b80-1953">例如，以下语句将 11 个字节写入文件号 1:</span><span class="sxs-lookup"><span data-stu-id="46b80-1953">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="46b80-1954">通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-1954">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1955">此示例使用`FilePut`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1955">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="46b80-1956">结构的 5 个记录`Person`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-1956">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-1957"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</span><span class="sxs-lookup"><span data-stu-id="46b80-1957"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-1958">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-1958">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1959">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1959">Required.</span></span> <span data-ttu-id="46b80-1960">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1960">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-1961">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1961">Required.</span></span> <span data-ttu-id="46b80-1962">有效变量名，它包含写入磁盘的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1962">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="46b80-1963">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-1963">Optional.</span></span> <span data-ttu-id="46b80-1964">开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</span><span class="sxs-lookup"><span data-stu-id="46b80-1964">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="46b80-1965">将变量中得数据写入磁盘文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-1965">Writes data from a variable to a disk file.</span></span>  <span data-ttu-id="46b80-1966">相比 <see langword="FilePutObject" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-1966">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span></span> <span data-ttu-id="46b80-1967">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-1967">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-1968">`FilePutObject`而不是使用函数`FilePut`以避免多义性在编译时，如果类型`Object`而不是另一个类型，如传递`Integer`， `Long`， `Short`，依次类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1968">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="46b80-1969">`FilePutObject` 写入和读取描述对象的描述符。</span><span class="sxs-lookup"><span data-stu-id="46b80-1969">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="46b80-1970">如果你想要写出`Variant`类型，`FilePutObject`是必需的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1970">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="46b80-1971">当有疑问时，如果第二个参数使用一个对象，我们建议您始终使用`FilePutObject`和`FileGetObject`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1971">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="46b80-1972">`FilePutObject` 仅在中有效`Random`和`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-1972">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-1973">通常使用 `FileGetObject` 从文件中读取使用 `FilePutObject` 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-1973">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="46b80-1974">第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-1974">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="46b80-1975">如果省略`RecordNumber`，`FilePutObject`上次写入的下一步的记录或字节`FileGetObject`或`FilePutObject`函数 (或记录或字节指向由最后一个`Seek`函数)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1975">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="46b80-1976">`StringIsFixedLength`参数控制是否函数将字符串解释为变量或固定长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1976">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="46b80-1977">`FilePutObject` 如果参数为本身不会写入长度描述符`True`。</span><span class="sxs-lookup"><span data-stu-id="46b80-1977">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="46b80-1978">如果你使用`StringIsFixedLength`  =  `True`与`FilePutObject`，您需要做相同，但有`FileGetObject`，和你还必须确保此字符串初始化为所需的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1978">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="46b80-1979">随机模式</span><span class="sxs-lookup"><span data-stu-id="46b80-1979">Random Mode</span></span>  
 <span data-ttu-id="46b80-1980">打开的文件中`Random`模式下，以下规则适用：</span><span class="sxs-lookup"><span data-stu-id="46b80-1980">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="46b80-1981">如果要写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePutObject`将后续记录写入记录长度边界上。</span><span class="sxs-lookup"><span data-stu-id="46b80-1981">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="46b80-1982">将文件缓冲区的现有内容，则填充一个记录的结尾和开始下一条记录之间的空间。</span><span class="sxs-lookup"><span data-stu-id="46b80-1982">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="46b80-1983">因为无法精确地确定填充的数据量，它通常是具有要写入的数据长度相匹配的记录长度一个好办法。</span><span class="sxs-lookup"><span data-stu-id="46b80-1983">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="46b80-1984">如果要写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="46b80-1984">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="46b80-1985">写入的变量是否包含数值类型的对象`FilePutObject`写入两个字节以标识`VarType`的对象，然后将该变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-1985">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="46b80-1986">例如，当编写一个对象时，包含一个整数，`FilePutObject`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 包含的数据的四个字节。</span><span class="sxs-lookup"><span data-stu-id="46b80-1986">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="46b80-1987">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储变量所需的字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-1987">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="46b80-1988">如果写入的变量是一个对象，包含一个字符串，`FilePutObject`写入一个双字节说明符标识`VarType(8)`的对象，然后。</span><span class="sxs-lookup"><span data-stu-id="46b80-1988">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="46b80-1989">指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为四个字节大于字符串的实际长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-1989">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="46b80-1990">如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并且读取到应正确长度的字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1990">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="46b80-1991">如果写入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 子句指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。</span><span class="sxs-lookup"><span data-stu-id="46b80-1991">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="46b80-1992">描述符指定的秩的数组、 大小和为每个级别的下限。</span><span class="sxs-lookup"><span data-stu-id="46b80-1992">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="46b80-1993">其长度等于 2 + 8 倍的维数: (2 + 8 \* NumberOfDimensions)。</span><span class="sxs-lookup"><span data-stu-id="46b80-1993">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="46b80-1994">二进制模式下</span><span class="sxs-lookup"><span data-stu-id="46b80-1994">Binary Mode</span></span>  
 <span data-ttu-id="46b80-1995">打开的文件中`Binary`模式下，所有`Random`模式规则适用，除外：</span><span class="sxs-lookup"><span data-stu-id="46b80-1995">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="46b80-1996">`RecordLength`中的子句`FileOpen`函数不起任何作用。</span><span class="sxs-lookup"><span data-stu-id="46b80-1996">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="46b80-1997">`FilePutObject` 将所有变量磁盘连续，即包含无记录之间的填充。</span><span class="sxs-lookup"><span data-stu-id="46b80-1997">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-1998">此示例使用`FilePutObject`函数以向文件写入一个字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-1998">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-1999">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-1999">Required.</span></span> <span data-ttu-id="46b80-2000">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2000">Any valid file number.</span></span></param>
        <param name="RecordWidth"><span data-ttu-id="46b80-2001">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2001">Required.</span></span> <span data-ttu-id="46b80-2002">0 到 255（包括 0 和 255）范围内的数值表达式，它表示在开始新一行前每一行中所显示的字符数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2002">Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</span></span> <span data-ttu-id="46b80-2003">如果 <c>RecordWidth</c> 等于 0，则行的长度没有限制。</span><span class="sxs-lookup"><span data-stu-id="46b80-2003">If <c>RecordWidth</c> equals 0, there is no limit to the length of a line.</span></span> <span data-ttu-id="46b80-2004"><c>RecordWidth</c> 的默认值为 0。</span><span class="sxs-lookup"><span data-stu-id="46b80-2004">The default value for <c>RecordWidth</c> is 0.</span></span></param>
        <summary><span data-ttu-id="46b80-2005">为用 <see langword="FileOpen" /> 函数打开的文件分配输出行宽。</span><span class="sxs-lookup"><span data-stu-id="46b80-2005">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="46b80-2006">此示例使用`FileWidth`函数可设置文件的输出线条宽度。</span><span class="sxs-lookup"><span data-stu-id="46b80-2006">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2007">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2007">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="46b80-2008">返回一个 <see langword="Integer" /> 值，该值表示 <see langword="FileOpen" /> 函数可用的下一个文件号。</span><span class="sxs-lookup"><span data-stu-id="46b80-2008">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></summary>
        <returns><span data-ttu-id="46b80-2009">返回一个 <see langword="Integer" /> 值，该值表示 <see langword="FileOpen" /> 函数可用的下一个文件号。</span><span class="sxs-lookup"><span data-stu-id="46b80-2009">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2010">使用`FreeFile`提供尚未使用文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2010">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2011">此示例使用`FreeFile`函数以返回下一个可用的文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2011">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="46b80-2012">输出在循环中，打开五个文件和一些示例数据写入到每个。</span><span class="sxs-lookup"><span data-stu-id="46b80-2012">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2013">正在使用的文件数超过 255。</span><span class="sxs-lookup"><span data-stu-id="46b80-2013">More than 255 files are in use.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="46b80-2014">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2014">Required.</span></span> <span data-ttu-id="46b80-2015">指定一个文件名、目录名或文件夹名的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2015"><see langword="String" /> expression that specifies a file, directory, or folder name.</span></span> <span data-ttu-id="46b80-2016"><c>PathName</c> 可以包含目录或文件夹以及驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-2016"><c>PathName</c> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="46b80-2017">返回一个表示文件、目录或文件夹的特性的 <see langword="FileAttribute" /> 值。</span><span class="sxs-lookup"><span data-stu-id="46b80-2017">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span></span> <span data-ttu-id="46b80-2018">相比 <see langword="FileAttribute" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2018">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span></span> <span data-ttu-id="46b80-2019">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2019">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="46b80-2020">由 <see langword="GetAttr" /> 返回的值是下列枚举值的和：</span><span class="sxs-lookup"><span data-stu-id="46b80-2020">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:</span></span>  
  
 <span data-ttu-id="46b80-2021"><list type="table"><item><term> 值</span><span class="sxs-lookup"><span data-stu-id="46b80-2021"><list type="table"><item><term> Value</span></span>  
  
 <span data-ttu-id="46b80-2022"></term><description> 常量</span><span class="sxs-lookup"><span data-stu-id="46b80-2022"></term><description> Constant</span></span>  
  
 <span data-ttu-id="46b80-2023"></description><description> 描述</span><span class="sxs-lookup"><span data-stu-id="46b80-2023"></description><description> Description</span></span>  
  
 <span data-ttu-id="46b80-2024"></description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> 常规。</span><span class="sxs-lookup"><span data-stu-id="46b80-2024"></description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.</span></span>  
  
 <span data-ttu-id="46b80-2025"></description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> 只读。</span><span class="sxs-lookup"><span data-stu-id="46b80-2025"></description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.</span></span>  
  
 <span data-ttu-id="46b80-2026"></description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> 隐藏。</span><span class="sxs-lookup"><span data-stu-id="46b80-2026"></description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.</span></span>  
  
 <span data-ttu-id="46b80-2027"></description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> 系统文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2027"></description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.</span></span>  
  
 <span data-ttu-id="46b80-2028"></description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> 目录或文件夹。</span><span class="sxs-lookup"><span data-stu-id="46b80-2028"></description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.</span></span>  
  
 <span data-ttu-id="46b80-2029"></description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> 文件自上次备份后已更改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2029"></description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.</span></span>  
  
 <span data-ttu-id="46b80-2030"></description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> 文件具有不同的名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-2030"></description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.</span></span>  
  
 </description></item></list><block subset="none" type="note"><para>  
 <span data-ttu-id="46b80-2031">这些枚举是由 Visual Basic 语言指定的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2031">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="46b80-2032">可以在代码中的任何位置使用这些名称以代替实际值。</span><span class="sxs-lookup"><span data-stu-id="46b80-2032">The names can be used anywhere in your code in place of the actual values.</span></span>  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2033">若要确定设置了哪些属性，请使用`And`运算符执行返回的值的按位比较`GetAttr`函数和所需的各个文件属性的值。</span><span class="sxs-lookup"><span data-stu-id="46b80-2033">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="46b80-2034">如果结果不为零，则该属性设置为指定的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2034">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="46b80-2035">例如，以下的返回值`And`表达式是零 if`Archive`未设置属性：</span><span class="sxs-lookup"><span data-stu-id="46b80-2035">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="46b80-2036">如果返回非零值`Archive`属性设置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2036">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2037">此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。</span><span class="sxs-lookup"><span data-stu-id="46b80-2037">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="46b80-2038"><paramref name="Pathname" /> 无效或包含通配符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2038"><paramref name="Pathname" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="46b80-2039">目标文件不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2039">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-2040">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2040">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2041">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2041">Required.</span></span> <span data-ttu-id="46b80-2042">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2042">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2043">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2043">Required.</span></span> <span data-ttu-id="46b80-2044">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2044">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2045">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2045">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2046">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2046">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2047">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2047">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2048">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2048">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2049">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2049">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2050">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2050">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2051">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2051">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2052">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2052">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2053">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2053">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2054">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2054">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2055">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2055">Data</span></span>|<span data-ttu-id="46b80-2056">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2056">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2057">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2057">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2058">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2058">Empty</span></span>|  
|<span data-ttu-id="46b80-2059">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2059">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2060">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2060">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2061">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2061">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2062">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2062">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2063">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2063">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2064">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2064">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2065">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2065">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2066">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2066">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2067">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2067">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2068">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2068">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2069">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2069">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2070">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2070">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2071">此示例假定`TestFile`是具有某些行写入到它使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2071">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2072">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2072">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2073">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2073">Required.</span></span> <span data-ttu-id="46b80-2074">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2074">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2075">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2075">Required.</span></span> <span data-ttu-id="46b80-2076">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2076">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2077">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2077">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2078">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2078">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2079">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2079">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2080">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2080">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2081">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2081">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2082">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2082">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2083">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2083">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2084">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2084">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2085">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2085">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2086">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2086">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2087">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2087">Data</span></span>|<span data-ttu-id="46b80-2088">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2088">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2089">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2089">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2090">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2090">Empty</span></span>|  
|<span data-ttu-id="46b80-2091">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2091">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2092">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2092">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2093">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2093">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2094">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2094">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2095">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2095">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2096">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2096">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2097">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2097">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2098">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2098">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2099">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2099">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2100">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2100">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2101">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2101">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2102">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2102">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2103">此示例假定`TestFile`是具有某些行写入到它使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2103">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2104">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2104">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2105">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2105">Required.</span></span> <span data-ttu-id="46b80-2106">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2106">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2107">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2107">Required.</span></span> <span data-ttu-id="46b80-2108">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2108">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2109">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2109">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2110">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2110">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2111">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2111">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2112">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2112">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2113">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2113">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2114">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2114">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2115">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2115">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2116">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2116">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2117">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2117">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2118">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2118">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2119">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2119">Data</span></span>|<span data-ttu-id="46b80-2120">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2120">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2121">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2121">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2122">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2122">Empty</span></span>|  
|<span data-ttu-id="46b80-2123">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2123">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2124">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2124">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2125">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2125">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2126">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2126">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2127">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2127">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2128">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2128">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2129">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2129">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2130">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2130">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2131">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2131">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2132">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2132">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2133">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2133">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2134">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2134">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2135">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2135">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2136">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2136">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2137">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2137">Required.</span></span> <span data-ttu-id="46b80-2138">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2138">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2139">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2139">Required.</span></span> <span data-ttu-id="46b80-2140">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2140">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2141">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2141">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2142">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2142">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2143">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2143">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2144">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2144">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2145">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2145">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2146">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2146">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2147">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2147">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2148">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2148">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2149">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2149">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2150">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2150">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2151">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2151">Data</span></span>|<span data-ttu-id="46b80-2152">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2152">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2153">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2153">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2154">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2154">Empty</span></span>|  
|<span data-ttu-id="46b80-2155">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2155">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2156">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2156">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2157">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2157">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2158">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2158">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2159">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2159">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2160">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2160">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2161">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2161">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2162">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2162">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2163">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2163">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2164">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2164">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2165">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2165">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2166">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2166">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2167">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2167">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2168">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2168">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2169">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2169">Required.</span></span> <span data-ttu-id="46b80-2170">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2170">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2171">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2171">Required.</span></span> <span data-ttu-id="46b80-2172">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2172">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2173">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2173">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2174">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2174">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2175">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2175">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2176">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2176">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2177">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2177">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2178">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2178">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2179">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2179">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2180">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2180">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2181">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2181">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2182">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2182">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2183">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2183">Data</span></span>|<span data-ttu-id="46b80-2184">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2184">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2185">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2185">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2186">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2186">Empty</span></span>|  
|<span data-ttu-id="46b80-2187">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2187">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2188">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2188">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2189">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2189">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2190">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2190">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2191">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2191">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2192">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2192">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2193">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2193">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2194">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2194">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2195">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2195">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2196">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2196">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2197">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2197">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2198">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2198">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2199">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2199">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2200">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2200">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2201">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2201">Required.</span></span> <span data-ttu-id="46b80-2202">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2202">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2203">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2203">Required.</span></span> <span data-ttu-id="46b80-2204">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2204">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2205">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2205">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2206">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2206">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2207">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2207">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2208">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2208">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2209">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2209">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2210">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2210">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2211">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2211">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2212">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2212">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2213">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2213">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2214">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2214">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2215">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2215">Data</span></span>|<span data-ttu-id="46b80-2216">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2216">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2217">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2217">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2218">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2218">Empty</span></span>|  
|<span data-ttu-id="46b80-2219">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2219">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2220">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2220">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2221">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2221">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2222">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2222">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2223">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2223">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2224">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2224">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2225">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2225">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2226">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2226">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2227">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2227">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2228">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2228">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2229">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2229">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2230">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2230">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2231">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2231">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2232">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2232">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2233">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2233">Required.</span></span> <span data-ttu-id="46b80-2234">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2234">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2235">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2235">Required.</span></span> <span data-ttu-id="46b80-2236">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2236">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2237">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2237">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2238">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2238">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2239">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2239">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2240">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2240">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2241">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2241">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2242">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2242">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2243">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2243">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2244">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2244">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2245">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2245">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2246">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2246">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2247">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2247">Data</span></span>|<span data-ttu-id="46b80-2248">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2248">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2249">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2249">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2250">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2250">Empty</span></span>|  
|<span data-ttu-id="46b80-2251">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2251">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2252">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2252">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2253">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2253">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2254">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2254">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2255">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2255">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2256">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2256">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2257">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2257">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2258">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2258">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2259">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2259">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2260">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2260">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2261">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2261">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2262">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2262">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2263">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2263">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2264">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2264">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2265">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2265">Required.</span></span> <span data-ttu-id="46b80-2266">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2266">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2267">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2267">Required.</span></span> <span data-ttu-id="46b80-2268">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2268">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2269">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2269">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2270">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2270">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2271">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2271">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2272">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2272">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2273">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2273">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2274">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2274">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2275">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2275">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2276">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2276">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2277">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2277">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2278">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2278">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2279">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2279">Data</span></span>|<span data-ttu-id="46b80-2280">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2280">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2281">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2281">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2282">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2282">Empty</span></span>|  
|<span data-ttu-id="46b80-2283">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2283">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2284">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2284">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2285">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2285">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2286">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2286">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2287">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2287">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2288">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2288">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2289">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2289">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2290">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2290">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2291">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2291">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2292">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2292">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2293">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2293">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2294">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2294">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2295">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2295">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2296">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2296">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2297">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2297">Required.</span></span> <span data-ttu-id="46b80-2298">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2298">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2299">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2299">Required.</span></span> <span data-ttu-id="46b80-2300">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2300">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2301">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2301">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2302">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2302">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2303">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2303">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2304">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2304">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2305">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2305">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2306">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2306">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2307">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2307">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2308">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2308">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2309">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2309">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2310">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2310">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2311">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2311">Data</span></span>|<span data-ttu-id="46b80-2312">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2312">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2313">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2313">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2314">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2314">Empty</span></span>|  
|<span data-ttu-id="46b80-2315">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2315">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2316">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2316">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2317">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2317">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2318">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2318">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2319">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2319">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2320">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2320">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2321">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2321">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2322">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2322">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2323">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2323">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2324">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2324">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2325">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2325">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2326">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2326">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2327">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2327">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2328">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2328">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2329">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2329">Required.</span></span> <span data-ttu-id="46b80-2330">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2330">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2331">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2331">Required.</span></span> <span data-ttu-id="46b80-2332">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2332">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2333">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2333">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2334">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2334">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2335">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2335">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2336">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2336">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2337">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2337">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2338">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2338">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2339">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2339">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2340">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2340">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2341">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2341">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2342">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2342">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2343">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2343">Data</span></span>|<span data-ttu-id="46b80-2344">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2344">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2345">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2345">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2346">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2346">Empty</span></span>|  
|<span data-ttu-id="46b80-2347">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2347">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2348">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2348">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2349">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2349">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2350">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2350">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2351">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2351">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2352">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2352">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2353">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2353">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2354">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2354">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2355">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2355">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2356">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2356">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2357">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2357">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2358">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2358">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2359">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2359">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2360">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2360">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2361">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2361">Required.</span></span> <span data-ttu-id="46b80-2362">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2362">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2363">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2363">Required.</span></span> <span data-ttu-id="46b80-2364">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2364">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2365">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2365">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2366">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2366">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2367">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2367">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2368">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2368">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2369">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2369">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2370">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2370">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2371">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2371">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2372">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2372">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2373">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2373">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2374">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2374">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2375">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2375">Data</span></span>|<span data-ttu-id="46b80-2376">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2376">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2377">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2377">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2378">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2378">Empty</span></span>|  
|<span data-ttu-id="46b80-2379">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2379">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2380">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2380">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2381">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2381">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2382">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2382">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2383">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2383">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2384">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2384">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2385">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2385">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2386">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2386">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2387">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2387">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2388">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2388">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2389">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2389">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2390">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2390">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2391">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2391">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2392">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2392">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2393">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2393">Required.</span></span> <span data-ttu-id="46b80-2394">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2394">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="46b80-2395">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2395">Required.</span></span> <span data-ttu-id="46b80-2396">被赋以从文件中读取的值的变量不能是数组或对象变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2396">Variable that is assigned the values read from the file—cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="46b80-2397">读取打开的顺序文件中的数据，并将这些数据赋值给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2397">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2398">`Input`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2398">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2399">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2399">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2400">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2400">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2401">数据读取`Input`通过使用通常写入到文件`Write`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2401">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="46b80-2402">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2402">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2403">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2403">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2404">例如，名为 Form1.vb 文件可能不是 Visual Basic 2005 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2404">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="46b80-2405">读取时，标准字符串或数值数据就赋给变量而不进行修改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2405">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="46b80-2406">下表说明了如何处理其他输入的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2406">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="46b80-2407">数据</span><span class="sxs-lookup"><span data-stu-id="46b80-2407">Data</span></span>|<span data-ttu-id="46b80-2408">分配给变量的值</span><span class="sxs-lookup"><span data-stu-id="46b80-2408">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="46b80-2409">分隔逗号或空白的行</span><span class="sxs-lookup"><span data-stu-id="46b80-2409">Delimiting comma or blank line</span></span>|<span data-ttu-id="46b80-2410">空</span><span class="sxs-lookup"><span data-stu-id="46b80-2410">Empty</span></span>|  
|<span data-ttu-id="46b80-2411">#NULL#</span><span class="sxs-lookup"><span data-stu-id="46b80-2411">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="46b80-2412">#TRUE # 或 #FALSE #</span><span class="sxs-lookup"><span data-stu-id="46b80-2412">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="46b80-2413">`True` 或 `False`</span><span class="sxs-lookup"><span data-stu-id="46b80-2413">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="46b80-2414">日期和/或表达式所表示的时间</span><span class="sxs-lookup"><span data-stu-id="46b80-2414">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="46b80-2415">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="46b80-2415">#ERROR `errornumber`#</span></span>|<span data-ttu-id="46b80-2416">`errornumber` （变量是一个对象标记为错误）</span><span class="sxs-lookup"><span data-stu-id="46b80-2416">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="46b80-2417">如果在输入数据项时达到文件末尾，输入已停止，则会出错。</span><span class="sxs-lookup"><span data-stu-id="46b80-2417">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2418">`Input`函数未进行本地化。</span><span class="sxs-lookup"><span data-stu-id="46b80-2418">The `Input` function is not localized.</span></span> <span data-ttu-id="46b80-2419">例如，在德国的版本中，如果输入 3,14159，则返回仅 3，因为逗号将被视为变量分隔符而不是作为小数点。</span><span class="sxs-lookup"><span data-stu-id="46b80-2419">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2420">通过使用从文件读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2420">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2421">有关详情，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2421">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2422">此示例使用`Input`函数来从文件读取数据，到两个变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2422">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="46b80-2423">此示例假定`TestFile`是具有若干行写入其使用的数据的文件`Write`函数，每行都包含在引用和大量分隔用逗号进行分隔，例如字符串: ("Hello"，234)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2423">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2424">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2424">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2425">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2425">Required.</span></span> <span data-ttu-id="46b80-2426">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2426">Any valid file number.</span></span></param>
        <param name="CharCount"><span data-ttu-id="46b80-2427">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2427">Required.</span></span> <span data-ttu-id="46b80-2428">用于指定要读取的字符数的任何有效数值表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2428">Any valid numeric expression specifying the number of characters to read.</span></span></param>
        <summary><span data-ttu-id="46b80-2429">返回 <see langword="String" /> 值，该值包含以 <see langword="Input" /> 或 <see langword="Binary" /> 模式打开的文件中的字符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2429">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="46b80-2430">相比 <see langword="InputString" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2430">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span> <span data-ttu-id="46b80-2431">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2431">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="46b80-2432">返回 <see langword="String" /> 值，该值包含以 <see langword="Input" /> 或 <see langword="Binary" /> 模式打开的文件中的字符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2432">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="46b80-2433">相比 <see langword="InputString" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2433">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2434">`InputString`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2434">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2435">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2435">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2436">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2436">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2437">数据读取`InputString`函数通常通过使用写入到文件`Print`或`FilePut`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2437">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="46b80-2438">此函数只能用于的文件在打开`Input`或`Binary`模式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2438">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="46b80-2439">与不同`Input`函数，`InputString`函数返回它所读取的所有字符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2439">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="46b80-2440">这包括逗号、 回车、 换行符、 引号引起来和前导空格。</span><span class="sxs-lookup"><span data-stu-id="46b80-2440">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="46b80-2441">打开以进行文件与`Binary`访问，请尝试使用读取通过文件`InputString`函数直到`EOF`返回`True`生成错误。</span><span class="sxs-lookup"><span data-stu-id="46b80-2441">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="46b80-2442">使用`LOF`和`Loc`函数而不是`EOF`时通过使用读取二进制文件`InputString`，或使用`FileGet`当你使用`EOF`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2442">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2443">在从文件读取时，不要根据文件扩展名的文件的内容的相关安全决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2443">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="46b80-2444">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2444">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2445">此示例使用`InputString`函数从文件一次读取一个字符并将其打印到`Output`窗口。</span><span class="sxs-lookup"><span data-stu-id="46b80-2445">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="46b80-2446">此示例假定`MyFile`是具有的示例数据的若干行的文本文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2446">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="46b80-2447"><paramref name="FileNumber" /> 不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2447"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-2448"><paramref name="CharCount" />&lt; 0 或 &gt; 214。</span><span class="sxs-lookup"><span data-stu-id="46b80-2448"><paramref name="CharCount" /> &lt; 0 or &gt; 214.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="46b80-2449">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2449">Required.</span></span> <span data-ttu-id="46b80-2450">指定要删除的一个或多个文件名的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2450"><see langword="String" /> expression that specifies one or more file names to be deleted.</span></span> <span data-ttu-id="46b80-2451"><c>PathName</c> 可以包含目录或文件夹以及驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-2451"><c>PathName</c> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="46b80-2452">从磁盘中删除文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2452">Deletes files from a disk.</span></span> <span data-ttu-id="46b80-2453">相比 <see langword="Kill" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2453">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span></span> <span data-ttu-id="46b80-2454">有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2454">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2455">`Kill` 支持使用多个字符 (`*`) 和单字符 (`?`) 通配符来指定多个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2455">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="46b80-2456">**安全说明**才能执行，`Kill`函数需要`Read`和`PathDiscovery`标志<xref:System.Security.Permissions.FileIOPermission>才能被授予对执行代码。</span><span class="sxs-lookup"><span data-stu-id="46b80-2456">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="46b80-2457">有关详细信息，请参阅<xref:System.Security.SecurityException>[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="46b80-2457">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2458">此示例使用`Kill`函数从磁盘中删除文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2458">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2459">目标文件打开。</span><span class="sxs-lookup"><span data-stu-id="46b80-2459">Target file(s) open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="46b80-2460">目标文件未找到。</span><span class="sxs-lookup"><span data-stu-id="46b80-2460">Target file(s) not found.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="46b80-2461">权限被拒绝。</span><span class="sxs-lookup"><span data-stu-id="46b80-2461">Permission denied.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2462">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2462">Required.</span></span> <span data-ttu-id="46b80-2463">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2463">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="46b80-2464">从打开的顺序文件中读取一行并将其赋值给一个 <see langword="String" /> 变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2464">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></summary>
        <returns><span data-ttu-id="46b80-2465">从打开的顺序文件中读取一行并将其赋值给一个 <see langword="String" /> 变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2465">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2466">`LineInput`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2466">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2467">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2467">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2468">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2468">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2469">数据读取`LineInput`通过使用通常写入到文件`Print`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2469">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2470">在从文件读取时，不要根据文件扩展名的文件的内容的相关的决策。</span><span class="sxs-lookup"><span data-stu-id="46b80-2470">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="46b80-2471">例如，名为 Form1.vb 文件可能不是 Visual Basic 源文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2471">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="46b80-2472">`LineInput`函数一次直到它遇到一个回车读取从文件的一个字符 (`Chr(13)`) 或回车/换行 (`Chr(13) + Chr(10)`) 序列。</span><span class="sxs-lookup"><span data-stu-id="46b80-2472">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="46b80-2473">回车符/换行符源的序列将跳过而不是追加到字符字符串。</span><span class="sxs-lookup"><span data-stu-id="46b80-2473">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2474">通过使用从文件读取`LineInput`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2474">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2475">此示例使用`LineInput`函数以从顺序文件中读取一个行并将其分配给变量。</span><span class="sxs-lookup"><span data-stu-id="46b80-2475">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="46b80-2476">此示例假定`TestFile`是具有的示例数据的若干行的文本文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2476">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException"><span data-ttu-id="46b80-2477">到达文件末尾。</span><span class="sxs-lookup"><span data-stu-id="46b80-2477">End of file reached.</span></span></exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="46b80-2478"><paramref name="FileNumber" /> 不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2478"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2479">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2479">Required.</span></span> <span data-ttu-id="46b80-2480">任何有效的 <see langword="Integer" /> 文件号。</span><span class="sxs-lookup"><span data-stu-id="46b80-2480">Any valid <see langword="Integer" /> file number.</span></span></param>
        <summary><span data-ttu-id="46b80-2481">返回指定打开文件中当前读/写位置的 <see langword="Long" /> 值。</span><span class="sxs-lookup"><span data-stu-id="46b80-2481">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span></span></summary>
        <returns><span data-ttu-id="46b80-2482">返回指定打开文件中当前读/写位置的 <see langword="Long" /> 值。</span><span class="sxs-lookup"><span data-stu-id="46b80-2482">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2483">`Loc`函数是从零开始; 使用它来检索文件中的第一个字节将返回 0。</span><span class="sxs-lookup"><span data-stu-id="46b80-2483">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="46b80-2484">`Loc`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2484">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2485">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2485">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2486">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2486">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2487">下面介绍每种文件访问模式的返回值：</span><span class="sxs-lookup"><span data-stu-id="46b80-2487">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="46b80-2488">模式</span><span class="sxs-lookup"><span data-stu-id="46b80-2488">Mode</span></span>|<span data-ttu-id="46b80-2489">返回值</span><span class="sxs-lookup"><span data-stu-id="46b80-2489">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="46b80-2490">读取或写入到文件的最新记录数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2490">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="46b80-2491">除以 128 文件中的当前字节位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2491">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="46b80-2492">但是，通过返回信息`Loc`为顺序文件不是使用也不需要。</span><span class="sxs-lookup"><span data-stu-id="46b80-2492">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="46b80-2493">读取或写入的最后一个字节的位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2493">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2494">此示例使用`Loc`函数以返回打开的文件中的当前读/写位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2494">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="46b80-2495">此示例假定`MyFile`是具有的示例数据的若干行的文本文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2495">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2496">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2496">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-2497">控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。</span><span class="sxs-lookup"><span data-stu-id="46b80-2497">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="46b80-2498">与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2498">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="46b80-2499">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2499">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2500">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2500">Required.</span></span> <span data-ttu-id="46b80-2501">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2501">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="46b80-2502">控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。</span><span class="sxs-lookup"><span data-stu-id="46b80-2502">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="46b80-2503">与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2503">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="46b80-2504">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2504">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2505">`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2505">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="46b80-2506">`Lock` 和`Unlock`函数始终成对使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-2506">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="46b80-2507">自变量`Lock`和`Unlock`必须相同。</span><span class="sxs-lookup"><span data-stu-id="46b80-2507">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="46b80-2508">如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2508">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="46b80-2509">如果`Record`单独指定单个记录将锁定/解锁。</span><span class="sxs-lookup"><span data-stu-id="46b80-2509">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="46b80-2510">如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2510">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2511">此示例演示如何使用`Lock`和`Unlock`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2511">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="46b80-2512">此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2512">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2513">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2513">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2514">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2514">Required.</span></span> <span data-ttu-id="46b80-2515">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2515">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="46b80-2516">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2516">Optional.</span></span> <span data-ttu-id="46b80-2517">唯一要锁定或取消锁定的记录号或字节数</span><span class="sxs-lookup"><span data-stu-id="46b80-2517">Number of the only record or byte to lock or unlock</span></span></param>
        <summary><span data-ttu-id="46b80-2518">控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。</span><span class="sxs-lookup"><span data-stu-id="46b80-2518">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="46b80-2519">与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2519">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="46b80-2520">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2520">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2521">`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2521">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="46b80-2522">`Lock` 和`Unlock`函数始终成对使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-2522">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="46b80-2523">自变量`Lock`和`Unlock`必须相同。</span><span class="sxs-lookup"><span data-stu-id="46b80-2523">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="46b80-2524">如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2524">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="46b80-2525">如果`Record`单独指定单个记录将锁定/解锁。</span><span class="sxs-lookup"><span data-stu-id="46b80-2525">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="46b80-2526">如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2526">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2527">此示例演示如何使用`Lock`和`Unlock`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2527">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="46b80-2528">此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2528">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2529">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2529">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2530">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2530">Required.</span></span> <span data-ttu-id="46b80-2531">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2531">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="46b80-2532">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2532">Optional.</span></span> <span data-ttu-id="46b80-2533">第一个要锁定或取消锁定的记录号或字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2533">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="46b80-2534">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2534">Optional.</span></span> <span data-ttu-id="46b80-2535">最后一个要锁定或取消锁定的记录号或字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2535">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="46b80-2536">控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。</span><span class="sxs-lookup"><span data-stu-id="46b80-2536">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="46b80-2537">与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2537">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="46b80-2538">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2538">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2539">`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2539">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="46b80-2540">`Lock` 和`Unlock`函数始终成对使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-2540">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="46b80-2541">自变量`Lock`和`Unlock`必须相同。</span><span class="sxs-lookup"><span data-stu-id="46b80-2541">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="46b80-2542">如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2542">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="46b80-2543">如果`Record`单独指定单个记录将锁定/解锁。</span><span class="sxs-lookup"><span data-stu-id="46b80-2543">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="46b80-2544">如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2544">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2545">此示例演示如何使用`Lock`和`Unlock`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2545">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="46b80-2546">此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2546">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2547">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2547">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2548">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2548">Required.</span></span> <span data-ttu-id="46b80-2549">一个包含有效文件号的 <see langword="Integer" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2549">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="46b80-2550">返回一个 <see langword="Long" /> 值，该值表示使用 <see langword="FileOpen" /> 函数打开的文件的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="46b80-2550">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="46b80-2551">相比 <see langword="LOF" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2551">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span> <span data-ttu-id="46b80-2552">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2552">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="46b80-2553">返回一个 <see langword="Long" /> 值，该值表示使用 <see langword="FileOpen" /> 函数打开的文件的大小（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="46b80-2553">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="46b80-2554">相比 <see langword="LOF" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2554">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2555">使用`FileLen`函数来获取未打开的文件的长度。</span><span class="sxs-lookup"><span data-stu-id="46b80-2555">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2556">此示例使用`LOF`函数来确定打开的文件的大小。</span><span class="sxs-lookup"><span data-stu-id="46b80-2556">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="46b80-2557">此示例假定`TestFile`是包含示例数据的文本文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2557">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2558">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2558">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="46b80-2559">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2559">Required.</span></span> <span data-ttu-id="46b80-2560">标识要创建的目录的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2560"><see langword="String" /> expression that identifies the directory to be created.</span></span> <span data-ttu-id="46b80-2561"><c>Path</c> 可以包含驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-2561">The <c>Path</c> may include the drive.</span></span> <span data-ttu-id="46b80-2562">如果未指定驱动器，则 <see langword="MkDir" /> 在当前驱动器上创建新目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2562">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="46b80-2563">新建目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2563">Creates a new directory.</span></span> <span data-ttu-id="46b80-2564">相比 <see langword="MkDir" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2564">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span></span> <span data-ttu-id="46b80-2565">有关详情，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2565">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2566">此函数将创建一个新目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2566">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2567">此示例使用`MkDir`函数来创建一个目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2567">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="46b80-2568">如果未指定驱动器，当前的驱动器上创建新目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2568">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-2569"><paramref name="Path" /> 未指定或为空。</span><span class="sxs-lookup"><span data-stu-id="46b80-2569"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="46b80-2570">权限被拒绝。</span><span class="sxs-lookup"><span data-stu-id="46b80-2570">Permission denied.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2571">目录已存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2571">Directory already exists.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2572">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2572">Required.</span></span> <span data-ttu-id="46b80-2573">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2573">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="46b80-2574">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2574">Optional.</span></span> <span data-ttu-id="46b80-2575">要写入文件的零个或多个由逗号分隔的表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2575">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
 <span data-ttu-id="46b80-2576"><c>Output</c> 参数的设置是：</span><span class="sxs-lookup"><span data-stu-id="46b80-2576">The <c>Output</c> argument settings are:</span></span>  
  
 <span data-ttu-id="46b80-2577"><see langword="T:System.IO.IOException" />：文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2577"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="46b80-2578"><see langword="T:System.IO.IOException" />：<c>FileNumber</c> 不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2578"><see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span></span></param>
        <summary><span data-ttu-id="46b80-2579">将已设置显示格式的数据写入顺序文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2579">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2580">`Print`和`PrintLine`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2580">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2581">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2581">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2582">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2582">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2583">`Print` 不包括换行符末尾的换行符。但是，`PrintLine`包括换行符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2583">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="46b80-2584">数据使用编写`Print`从文件通常通过使用读取`LineInput`或`Input`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2584">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="46b80-2585">如果省略`Output`为`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2585">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="46b80-2586">将在选项卡上边界，但混合使用逗号上对齐多个以逗号分隔的表达式和`TAB`可能会导致不一致的结果。</span><span class="sxs-lookup"><span data-stu-id="46b80-2586">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="46b80-2587">有关`Boolean`数据，`True`或`False`打印。</span><span class="sxs-lookup"><span data-stu-id="46b80-2587">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="46b80-2588">`True`和`False`无论区域设置如何，都不翻译关键字。</span><span class="sxs-lookup"><span data-stu-id="46b80-2588">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="46b80-2589">日期数据写入文件，通过使用你的系统所识别的标准短日期格式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2589">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="46b80-2590">时的日期或时间组件缺失或为零时，仅提供部分是写入文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2590">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="46b80-2591">执行任何操作写入文件，如果`Output`数据为空。</span><span class="sxs-lookup"><span data-stu-id="46b80-2591">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="46b80-2592">但是，如果`Output`列表数据是`DBNull`，`Null`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2592">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="46b80-2593">有关`Error`数据，输出将显示为`Error errorcode`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2593">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="46b80-2594">`Error`关键字不会进行转换而不考虑区域设置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2594">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="46b80-2595">通过使用写入到文件的所有数据`Print`是国际通用的; 即，数据的格式正确使用适当的小数分隔符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2595">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="46b80-2596">如果用户想要输出以供多个区域设置中，数据`Write`应使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-2596">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="46b80-2597">通过使用对文件进行写入`Print`或`PrintLine`函数需要`Write`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2597">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2598">有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2598">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2599">此示例使用`Print`和`PrintLine`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2599">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2600">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2600">Required.</span></span> <span data-ttu-id="46b80-2601">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2601">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="46b80-2602">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2602">Optional.</span></span> <span data-ttu-id="46b80-2603">要写入文件的零个或多个由逗号分隔的表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2603">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
 <span data-ttu-id="46b80-2604"><c>Output</c> 参数的设置是：</span><span class="sxs-lookup"><span data-stu-id="46b80-2604">The <c>Output</c> argument settings are:</span></span>  
  
 <span data-ttu-id="46b80-2605"><see langword="T:System.IO.IOException" />：文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2605"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="46b80-2606"><see langword="T:System.IO.IOException" />：<c>FileNumber</c> 不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2606"><see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span></span></param>
        <summary><span data-ttu-id="46b80-2607">将已设置显示格式的数据写入顺序文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2607">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2608">`Print`和`PrintLine`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2608">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2609">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2609">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2610">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2610">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2611">`Print` 不包括换行符末尾的换行符。但是，`PrintLine`包括换行符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2611">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="46b80-2612">数据使用编写`Print`从文件通常通过使用读取`LineInput`或`Input`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2612">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="46b80-2613">如果省略`Output`为`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2613">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="46b80-2614">将在选项卡上边界，但混合使用逗号上对齐多个以逗号分隔的表达式和`TAB`可能会导致不一致的结果。</span><span class="sxs-lookup"><span data-stu-id="46b80-2614">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="46b80-2615">有关`Boolean`数据，`True`或`False`打印。</span><span class="sxs-lookup"><span data-stu-id="46b80-2615">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="46b80-2616">`True`和`False`无论区域设置如何，都不翻译关键字。</span><span class="sxs-lookup"><span data-stu-id="46b80-2616">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="46b80-2617">日期数据写入文件，通过使用系统所识别的标准短日期格式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2617">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="46b80-2618">时的日期或时间组件缺失或为零时，仅提供部分是写入文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2618">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="46b80-2619">执行任何操作写入文件，如果`Output`数据为空。</span><span class="sxs-lookup"><span data-stu-id="46b80-2619">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="46b80-2620">但是，如果`Output`列表数据是`DBNull`，`Null`写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2620">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="46b80-2621">有关`Error`数据，输出将显示为`Error errorcode`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2621">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="46b80-2622">`Error`关键字不会进行转换而不考虑区域设置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2622">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="46b80-2623">通过使用写入到文件的所有数据`Print`是国际通用的; 即，数据的格式正确使用适当的小数分隔符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2623">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="46b80-2624">如果用户想要输出以供多个区域设置中，数据`Write`应使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-2624">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="46b80-2625">通过使用对文件进行写入`Print`或`PrintLine`函数需要`Write`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2625">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2626">有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2626">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2627">此示例使用`Print`和`PrintLine`函数以将数据写入到文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2627">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath"><span data-ttu-id="46b80-2628">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2628">Required.</span></span> <span data-ttu-id="46b80-2629">指定现有文件名和位置的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2629"><see langword="String" /> expression that specifies the existing file name and location.</span></span> <span data-ttu-id="46b80-2630"><c>OldPath</c> 可以包含文件的目录和驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-2630"><c>OldPath</c> may include the directory, and drive, of the file.</span></span></param>
        <param name="NewPath"><span data-ttu-id="46b80-2631">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2631">Required.</span></span> <span data-ttu-id="46b80-2632">指定新文件名和位置的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2632"><see langword="String" /> expression that specifies the new file name and location.</span></span> <span data-ttu-id="46b80-2633"><c>NewPath</c> 可以包含目标位置的目录和驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-2633"><c>NewPath</c> may include directory and drive of the destination location.</span></span> <span data-ttu-id="46b80-2634"><c>NewPath</c> 指定的文件名不能是已存在的文件名。</span><span class="sxs-lookup"><span data-stu-id="46b80-2634">The file name specified by <c>NewPath</c> cannot already exist.</span></span></param>
        <summary><span data-ttu-id="46b80-2635">重命名磁盘文件或目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2635">Renames a disk file or directory.</span></span> <span data-ttu-id="46b80-2636">相比 <see langword="Rename" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2636">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span></span> <span data-ttu-id="46b80-2637">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2637">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2638">`Rename`函数重命名文件，并将其移动到不同的目录，如有必要。</span><span class="sxs-lookup"><span data-stu-id="46b80-2638">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="46b80-2639">`Rename`函数可以将文件移个驱动器，但它仅可以重命名现有目录时同时`NewPath`和`OldPath`位于相同的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="46b80-2639">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="46b80-2640">`Rename` 无法创建新文件或目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2640">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="46b80-2641">使用`Rename`函数对打开的文件产生错误。</span><span class="sxs-lookup"><span data-stu-id="46b80-2641">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="46b80-2642">重命名它前，必须先关闭打开的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2642">You must close an open file before renaming it.</span></span> <span data-ttu-id="46b80-2643">`Rename` 自变量不能包含多个字符 （\*） 和单字符 （？） 通配符。</span><span class="sxs-lookup"><span data-stu-id="46b80-2643">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="46b80-2644">使用时`Rename`以将文件从受保护的位置复制到受保护的位置，该文件，仍保持较低的限制的权限。</span><span class="sxs-lookup"><span data-stu-id="46b80-2644">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="46b80-2645">请检查以确保没有引入可能的安全风险。</span><span class="sxs-lookup"><span data-stu-id="46b80-2645">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2646">此示例使用`Rename`函数重命名文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2646">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="46b80-2647">此示例的目的，假定已指定的目录存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2647">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="46b80-2648">路径无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2648">Path is invalid.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="46b80-2649"><paramref name="OldPath" /> 文件不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2649"><paramref name="OldPath" /> file does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2650">无法重命名为不同的设备。</span><span class="sxs-lookup"><span data-stu-id="46b80-2650">Cannot rename to different device.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="46b80-2651">关闭所有使用 <see langword="FileOpen" /> 函数打开的磁盘文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2651">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="46b80-2652">相比 <see langword="Reset" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2652">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span></span> <span data-ttu-id="46b80-2653">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2653">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2654">`Reset`函数关闭打开的所有活动文件`FileOpen`函数，并且具有相同的功能`FileClose()`不带任何参数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2654">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2655">此示例使用`Reset`函数以关闭所有打开的文件并将所有文件缓冲区的内容写入到磁盘。</span><span class="sxs-lookup"><span data-stu-id="46b80-2655">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="46b80-2656">请注意，使用`Object`变量`FileNumber`作为一个字符串和数字。</span><span class="sxs-lookup"><span data-stu-id="46b80-2656">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="46b80-2657">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2657">Required.</span></span> <span data-ttu-id="46b80-2658">标识要移除的目录或文件夹的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2658"><see langword="String" /> expression that identifies the directory or folder to be removed.</span></span> <span data-ttu-id="46b80-2659"><c>Path</c> 可以包含驱动器。</span><span class="sxs-lookup"><span data-stu-id="46b80-2659"><c>Path</c> can include the drive.</span></span> <span data-ttu-id="46b80-2660">如果未指定驱动器，则 <see langword="RmDir" /> 移除当前驱动器上的目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2660">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="46b80-2661">移除现有目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2661">Removes an existing directory.</span></span> <span data-ttu-id="46b80-2662">相比 <see langword="RmDir" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2662">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span></span> <span data-ttu-id="46b80-2663">有关详情，请参阅<see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2663">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2664">如果你尝试使用，则会发生错误`RmDir`在包含文件的目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2664">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="46b80-2665">使用`Kill`函数以删除所有文件，然后尝试删除一个目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2665">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2666">此示例使用`RmDir`函数来删除现有的目录。</span><span class="sxs-lookup"><span data-stu-id="46b80-2666">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-2667"><paramref name="Path" /> 未指定或为空。</span><span class="sxs-lookup"><span data-stu-id="46b80-2667"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2668">目标目录包含文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2668">Target directory contains files.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="46b80-2669">目录不存在。</span><span class="sxs-lookup"><span data-stu-id="46b80-2669">Directory does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-2670">返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2670">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="46b80-2671">相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2671">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="46b80-2672">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2672">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2673">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2673">Required.</span></span> <span data-ttu-id="46b80-2674">一个包含有效文件号的 <see langword="Integer" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2674">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="46b80-2675">返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2675">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="46b80-2676">相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2676">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="46b80-2677">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2677">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="46b80-2678">返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2678">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2679">`Seek` 返回一个值介于 1 和 2,147,483,647 之间 (等效于 2 ^31-1) （含）。</span><span class="sxs-lookup"><span data-stu-id="46b80-2679">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="46b80-2680">下面介绍每种文件访问模式的返回值：</span><span class="sxs-lookup"><span data-stu-id="46b80-2680">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="46b80-2681">模式</span><span class="sxs-lookup"><span data-stu-id="46b80-2681">Mode</span></span>|<span data-ttu-id="46b80-2682">返回值</span><span class="sxs-lookup"><span data-stu-id="46b80-2682">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="46b80-2683">读取或写入的下一步记录号</span><span class="sxs-lookup"><span data-stu-id="46b80-2683">Number of the next record read or written</span></span>|  
|<span data-ttu-id="46b80-2684">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="46b80-2684">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="46b80-2685">下一步操作的发生的字节位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2685">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="46b80-2686">在文件中的第一个字节在位置 1，第二个字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-2686">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2687">此示例使用`Seek`函数来返回当前的文件位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2687">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="46b80-2688">该示例假定`TestFile`是一个文件，包含的记录是结构`Record`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2688">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="46b80-2689">打开的文件中`Random`模式下，`Seek`返回下一条记录的数目。</span><span class="sxs-lookup"><span data-stu-id="46b80-2689">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="46b80-2690">而在模式下打开的文件`Random`模式下，`Seek`返回下一步操作的发生的字节位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2690">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="46b80-2691">假定`TestFile`是包含若干行文本的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2691">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="46b80-2692">此示例使用`Seek`函数将位置设置为下一步读取或写入的文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-2692">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="46b80-2693">而在模式下打开的文件`Random`模式下，`Seek`设置下一步操作的发生的字节位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2693">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="46b80-2694">假定`TestFile`是包含若干行文本的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2694">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2695">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2695">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2696">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2696">Required.</span></span> <span data-ttu-id="46b80-2697">一个包含有效文件号的 <see langword="Integer" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2697">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <param name="Position"><span data-ttu-id="46b80-2698">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2698">Required.</span></span> <span data-ttu-id="46b80-2699">一个 1 到 2,147,483,647 范围内（包括 1 和 2,147,483,647）的数字，用于指示下一个读取/写入操作应该发生的位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2699">Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span></span></param>
        <summary><span data-ttu-id="46b80-2700">返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2700">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="46b80-2701">相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2701">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="46b80-2702">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2702">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2703">`Seek` 返回一个值介于 1 和 2,147,483,647 之间 (等效于 2 ^31-1) （含）。</span><span class="sxs-lookup"><span data-stu-id="46b80-2703">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="46b80-2704">下面介绍每种文件访问模式的返回值：</span><span class="sxs-lookup"><span data-stu-id="46b80-2704">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="46b80-2705">模式</span><span class="sxs-lookup"><span data-stu-id="46b80-2705">Mode</span></span>|<span data-ttu-id="46b80-2706">返回值</span><span class="sxs-lookup"><span data-stu-id="46b80-2706">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="46b80-2707">读取或写入的下一步记录号</span><span class="sxs-lookup"><span data-stu-id="46b80-2707">Number of the next record read or written</span></span>|  
|<span data-ttu-id="46b80-2708">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="46b80-2708">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="46b80-2709">下一步操作的发生的字节位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2709">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="46b80-2710">在文件中的第一个字节在位置 1，第二个字节在位置 2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="46b80-2710">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2711">此示例使用`Seek`函数来返回当前的文件位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2711">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="46b80-2712">该示例假定`TestFile`是一个文件，包含的记录是结构`Record`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2712">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="46b80-2713">打开的文件中`Random`模式下，`Seek`返回下一条记录的数目。</span><span class="sxs-lookup"><span data-stu-id="46b80-2713">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="46b80-2714">而在模式下打开的文件`Random`模式下，`Seek`返回下一步操作的发生的字节位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2714">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="46b80-2715">假定`TestFile`是包含若干行文本的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2715">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="46b80-2716">此示例使用`Seek`函数将位置设置为下一步读取或写入的文件中。</span><span class="sxs-lookup"><span data-stu-id="46b80-2716">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="46b80-2717">而在模式下打开的文件`Random`模式下，`Seek`设置下一步操作的发生的字节位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2717">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="46b80-2718">假定`TestFile`是包含若干行文本的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2718">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2719">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2719">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="46b80-2720">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2720">Required.</span></span> <span data-ttu-id="46b80-2721">指定一个文件名的 <see langword="String" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2721"><see langword="String" /> expression that specifies a file name.</span></span> <span data-ttu-id="46b80-2722"><c>PathName</c> 可以包含驱动器和目录或文件夹。</span><span class="sxs-lookup"><span data-stu-id="46b80-2722"><c>PathName</c> can include directory or folder, and drive.</span></span></param>
        <param name="Attributes"><span data-ttu-id="46b80-2723">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2723">Required.</span></span> <span data-ttu-id="46b80-2724">常量或数值表达式，所有这些值一起指定文件特性。</span><span class="sxs-lookup"><span data-stu-id="46b80-2724">Constant or numeric expression, whose sum specifies file attributes.</span></span></param>
        <summary><span data-ttu-id="46b80-2725">设置文件的特性信息。</span><span class="sxs-lookup"><span data-stu-id="46b80-2725">Sets attribute information for a file.</span></span> <span data-ttu-id="46b80-2726">相比 <see langword="SetAttr" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</span><span class="sxs-lookup"><span data-stu-id="46b80-2726">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span></span> <span data-ttu-id="46b80-2727">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2727">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2728">如果您尝试设置打开的文件的属性，则会发生运行时错误。</span><span class="sxs-lookup"><span data-stu-id="46b80-2728">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="46b80-2729">`Attributes`参数枚举值如下所示：</span><span class="sxs-lookup"><span data-stu-id="46b80-2729">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="46b80-2730">“值”</span><span class="sxs-lookup"><span data-stu-id="46b80-2730">Value</span></span>|<span data-ttu-id="46b80-2731">返回的常量</span><span class="sxs-lookup"><span data-stu-id="46b80-2731">Constant</span></span>|<span data-ttu-id="46b80-2732">描述</span><span class="sxs-lookup"><span data-stu-id="46b80-2732">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="46b80-2733">正常 （默认值）。</span><span class="sxs-lookup"><span data-stu-id="46b80-2733">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="46b80-2734">只读。</span><span class="sxs-lookup"><span data-stu-id="46b80-2734">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="46b80-2735">隐藏。</span><span class="sxs-lookup"><span data-stu-id="46b80-2735">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="46b80-2736">系统文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2736">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="46b80-2737">卷标</span><span class="sxs-lookup"><span data-stu-id="46b80-2737">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="46b80-2738">目录或文件夹。</span><span class="sxs-lookup"><span data-stu-id="46b80-2738">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="46b80-2739">文件自上次备份后已更改。</span><span class="sxs-lookup"><span data-stu-id="46b80-2739">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="46b80-2740">文件具有不同的名称。</span><span class="sxs-lookup"><span data-stu-id="46b80-2740">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2741">这些枚举是由 Visual Basic 语言指定的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2741">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="46b80-2742">名称可以使用而非实际值在代码中的任意位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2742">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2743">此示例使用`SetAttr`函数可设置文件的特性。</span><span class="sxs-lookup"><span data-stu-id="46b80-2743">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="46b80-2744"><paramref name="Attribute" /> 类型无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2744"><paramref name="Attribute" /> type is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count"><span data-ttu-id="46b80-2745">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2745">Required.</span></span> <span data-ttu-id="46b80-2746">在显示或输出列表中下一个表达式之前要插入的空格数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2746">The number of spaces to insert before displaying or printing the next expression in a list.</span></span></param>
        <summary><span data-ttu-id="46b80-2747">与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2747">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></summary>
        <returns><span data-ttu-id="46b80-2748">与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2748">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2749">如果`Count`小于输出线条宽度下, 一步打印位置立即遵循的打印的空格数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2749">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="46b80-2750">如果`Count`大于输出线条宽度，`SPC`计算使用公式的下一步打印位置：</span><span class="sxs-lookup"><span data-stu-id="46b80-2750">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="46b80-2751">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="46b80-2751">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="46b80-2752">例如，如果打印当前位置为 24，输出行宽度为 80，并指定`SPC(90)`，则下一步打印将开始从位置 34 （打印当前位置 + 90/80 的余数）。</span><span class="sxs-lookup"><span data-stu-id="46b80-2752">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="46b80-2753">如果当前打印位置和输出线条宽度之间的区别在于小于`Count`(或`Count` `Mod` *宽度*)，则`SPC`函数将跳到下一步的行的开头，并生成空间等于`Count`– (*宽度*–*小于*)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2753">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2754">请确保表格列的宽度足以容纳较宽的字母。</span><span class="sxs-lookup"><span data-stu-id="46b80-2754">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2755">此示例使用`SPC`函数位置输出文件中和在**输出**窗口。</span><span class="sxs-lookup"><span data-stu-id="46b80-2755">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-2756">与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2756">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="46b80-2757">与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2757">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="46b80-2758">与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2758">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2759">如果在当前行的当前打印位置大于`Column`，`TAB`跳过为列的值等于`Column`下一步的输出行上。</span><span class="sxs-lookup"><span data-stu-id="46b80-2759">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="46b80-2760">如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。</span><span class="sxs-lookup"><span data-stu-id="46b80-2760">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="46b80-2761">如果`Column`大于输出线条宽度，`TAB`计算使用公式的下一步打印位置：</span><span class="sxs-lookup"><span data-stu-id="46b80-2761">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="46b80-2762">Mod 列宽</span><span class="sxs-lookup"><span data-stu-id="46b80-2762">Column Mod width</span></span>  
  
 <span data-ttu-id="46b80-2763">例如，如果*宽度*是 80，并指定`TAB(90)`，则下一个打印将开始列 10 （90/80 的余数）。</span><span class="sxs-lookup"><span data-stu-id="46b80-2763">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="46b80-2764">如果`Column`小于当前打印位置，在下一行计算的输出位置的打印启动。</span><span class="sxs-lookup"><span data-stu-id="46b80-2764">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="46b80-2765">如果计算出的打印位置大于当前打印位置，打印开始计算在同一行上打印位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2765">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="46b80-2766">在输出行上的最左边打印位置始终为 1。</span><span class="sxs-lookup"><span data-stu-id="46b80-2766">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="46b80-2767">当你使用`Print`或`PrintLine`函数来打印到文件，最右边的打印位置是输出文件中，你可以使用设置的当前宽度`FileWidth`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2767">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="46b80-2768">`TAB`函数还可用于`WriteLine`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2768">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="46b80-2769">它不能与使用<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2769">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2770">请确保表格列的宽度足以包含较宽的字母。</span><span class="sxs-lookup"><span data-stu-id="46b80-2770">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2771">此示例使用`TAB`函数位置输出文件中和在**输出**窗口。</span><span class="sxs-lookup"><span data-stu-id="46b80-2771">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column"><span data-ttu-id="46b80-2772">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2772">Optional.</span></span> <span data-ttu-id="46b80-2773">在显示或输出列表中下一个表达式之前要移动到的列号。</span><span class="sxs-lookup"><span data-stu-id="46b80-2773">The column number moved to before displaying or printing the next expression in a list.</span></span> <span data-ttu-id="46b80-2774">如果省略它，则 <see langword="TAB" /> 将插入点移动到下一个打印区域的开始位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2774">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span></span></param>
        <summary><span data-ttu-id="46b80-2775">与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2775">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="46b80-2776">与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</span><span class="sxs-lookup"><span data-stu-id="46b80-2776">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2777">如果在当前行的当前打印位置大于`Column`，`TAB`跳过为列的值等于`Column`下一步的输出行上。</span><span class="sxs-lookup"><span data-stu-id="46b80-2777">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="46b80-2778">如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。</span><span class="sxs-lookup"><span data-stu-id="46b80-2778">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="46b80-2779">如果`Column`大于输出线条宽度，`TAB`计算使用公式的下一步打印位置：</span><span class="sxs-lookup"><span data-stu-id="46b80-2779">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="46b80-2780">Mod 列宽</span><span class="sxs-lookup"><span data-stu-id="46b80-2780">Column Mod width</span></span>  
  
 <span data-ttu-id="46b80-2781">例如，如果*宽度*是 80，并指定`TAB(90)`，则下一个打印将开始列 10 （90/80 的余数）。</span><span class="sxs-lookup"><span data-stu-id="46b80-2781">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="46b80-2782">如果`Column`小于当前打印位置，在下一行计算的输出位置的打印启动。</span><span class="sxs-lookup"><span data-stu-id="46b80-2782">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="46b80-2783">如果计算出的打印位置大于当前打印位置，打印开始计算在同一行上打印位置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2783">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="46b80-2784">在输出行上的最左边打印位置始终为 1。</span><span class="sxs-lookup"><span data-stu-id="46b80-2784">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="46b80-2785">当你使用`Print`或`PrintLine`函数来打印到文件，最右边的打印位置是输出文件中，你可以使用设置的当前宽度`FileWidth`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2785">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="46b80-2786">`TAB`函数还可用于`WriteLine`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2786">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="46b80-2787">它不能与使用<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2787">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="46b80-2788">请确保表格列的宽度足以包含较宽的字母。</span><span class="sxs-lookup"><span data-stu-id="46b80-2788">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2789">此示例使用`TAB`函数位置输出文件中和在**输出**窗口。</span><span class="sxs-lookup"><span data-stu-id="46b80-2789">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="46b80-2790">控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。</span><span class="sxs-lookup"><span data-stu-id="46b80-2790">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="46b80-2791">与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2791">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="46b80-2792">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2792">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2793">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2793">Required.</span></span> <span data-ttu-id="46b80-2794">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2794">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="46b80-2795">控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。</span><span class="sxs-lookup"><span data-stu-id="46b80-2795">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="46b80-2796">与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2796">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="46b80-2797">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2797">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2798">`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2798">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="46b80-2799">`Lock` 和`Unlock`函数始终成对使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-2799">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="46b80-2800">自变量`Lock`和`Unlock`必须相同。</span><span class="sxs-lookup"><span data-stu-id="46b80-2800">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="46b80-2801">如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2801">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="46b80-2802">如果`Record`单独指定单个记录将锁定/解锁。</span><span class="sxs-lookup"><span data-stu-id="46b80-2802">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="46b80-2803">如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2803">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2804">此示例演示如何使用`Lock`和`Unlock`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2804">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="46b80-2805">此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2805">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2806">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2806">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2807">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2807">Required.</span></span> <span data-ttu-id="46b80-2808">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2808">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="46b80-2809">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2809">Optional.</span></span> <span data-ttu-id="46b80-2810">唯一要锁定或取消锁定的记录号或字节数</span><span class="sxs-lookup"><span data-stu-id="46b80-2810">Number of the only record or byte to lock or unlock</span></span></param>
        <summary><span data-ttu-id="46b80-2811">控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。</span><span class="sxs-lookup"><span data-stu-id="46b80-2811">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="46b80-2812">与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2812">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="46b80-2813">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2813">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2814">`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2814">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="46b80-2815">`Lock` 和`Unlock`函数始终成对使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-2815">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="46b80-2816">自变量`Lock`和`Unlock`必须相同。</span><span class="sxs-lookup"><span data-stu-id="46b80-2816">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="46b80-2817">如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2817">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="46b80-2818">如果`Record`单独指定单个记录将锁定/解锁。</span><span class="sxs-lookup"><span data-stu-id="46b80-2818">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="46b80-2819">如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2819">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2820">此示例演示如何使用`Lock`和`Unlock`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2820">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="46b80-2821">此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2821">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2822">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2822">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2823">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2823">Required.</span></span> <span data-ttu-id="46b80-2824">任何有效文件数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2824">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="46b80-2825">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2825">Optional.</span></span> <span data-ttu-id="46b80-2826">第一个要锁定或取消锁定的记录号或字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2826">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="46b80-2827">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2827">Optional.</span></span> <span data-ttu-id="46b80-2828">最后一个要锁定或取消锁定的记录号或字节数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2828">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="46b80-2829">控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。</span><span class="sxs-lookup"><span data-stu-id="46b80-2829">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="46b80-2830">与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2830">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="46b80-2831">有关详情，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</span><span class="sxs-lookup"><span data-stu-id="46b80-2831">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2832">`Lock`和`Unlock`函数是在环境中使用其中多个进程可能需要访问同一文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2832">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="46b80-2833">`Lock` 和`Unlock`函数始终成对使用。</span><span class="sxs-lookup"><span data-stu-id="46b80-2833">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="46b80-2834">自变量`Lock`和`Unlock`必须相同。</span><span class="sxs-lookup"><span data-stu-id="46b80-2834">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="46b80-2835">如果`Record`，或`FromRecord`和`ToRecord`是未提供，将被锁定整个文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2835">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="46b80-2836">如果`Record`单独指定单个记录将锁定/解锁。</span><span class="sxs-lookup"><span data-stu-id="46b80-2836">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="46b80-2837">如果已打开文件进行连续的输入或输出，`Lock`和`Unlock`影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2837">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2838">此示例演示如何使用`Lock`和`Unlock`函数。</span><span class="sxs-lookup"><span data-stu-id="46b80-2838">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="46b80-2839">此示例假定`People.txt`是一个文件，包含的记录是结构`Person`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2839">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2840">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2840">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2841">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2841">Required.</span></span> <span data-ttu-id="46b80-2842">包含任何有效文件数的 <see langword="Integer" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2842">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="46b80-2843">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2843">Optional.</span></span> <span data-ttu-id="46b80-2844">要写入文件的一个或多个由逗号分隔的表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2844">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="46b80-2845">将数据写入一个顺序文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2845">Writes data to a sequential file.</span></span> <span data-ttu-id="46b80-2846">通常使用 <see langword="Input" /> 从文件中读取使用 <see langword="Write" /> 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2846">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2847">`Write`和`WriteLine`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2847">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2848">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2848">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2849">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2849">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2850">如果省略`Output`，向文件打印一个空行。</span><span class="sxs-lookup"><span data-stu-id="46b80-2850">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="46b80-2851">可以用逗号分隔多个表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2851">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="46b80-2852">与不同`Print`函数，`Write`函数插入项与字符串周围的引号之间的逗号，按它们写入到文件的形式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2852">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="46b80-2853">无需显式分隔符放入列表。</span><span class="sxs-lookup"><span data-stu-id="46b80-2853">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="46b80-2854">当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2854">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="46b80-2855">下面的通用假设遵循这样的数据始终能够阅读和使用正确的解释`Input`，而不考虑区域设置：</span><span class="sxs-lookup"><span data-stu-id="46b80-2855">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="46b80-2856">使用句点作为小数分隔符始终写入数值数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2856">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="46b80-2857">有关`Boolean`数据，`#TRUE#`或`#FALSE#`打印。</span><span class="sxs-lookup"><span data-stu-id="46b80-2857">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="46b80-2858">`True`和`False`无论区域设置如何，都不翻译关键字。</span><span class="sxs-lookup"><span data-stu-id="46b80-2858">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="46b80-2859">日期数据写入到使用的通用日期格式的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2859">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="46b80-2860">时的日期或时间组件缺失或为零时，仅提供部分是写入文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2860">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="46b80-2861">执行任何操作写入文件，如果`Output`数据为空。</span><span class="sxs-lookup"><span data-stu-id="46b80-2861">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="46b80-2862">但是，对于 null 数据一样，`#NULL#`写入。</span><span class="sxs-lookup"><span data-stu-id="46b80-2862">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="46b80-2863">有关`Error`数据，输出将显示为`#ERROR errorcode#`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2863">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="46b80-2864">`Error`不转换关键字，而不考虑区域设置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2864">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="46b80-2865">`WriteLine` 将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2865">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="46b80-2866">可以在字符串中嵌入引号引起来通过使用双引号括起来，或""。</span><span class="sxs-lookup"><span data-stu-id="46b80-2866">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="46b80-2867">例如，应用于对象的</span><span class="sxs-lookup"><span data-stu-id="46b80-2867">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="46b80-2868">返回的值的字符串`Double quotation marks aren't "difficult" to handle`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2868">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="46b80-2869">通过使用对文件进行写入`Write`或`WriteLine`函数需要`Append`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2869">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2870">有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2870">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2871">此示例使用`Write`函数以将原始数据写入到顺序的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2871">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="46b80-2872">文件模式无效。</span><span class="sxs-lookup"><span data-stu-id="46b80-2872">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="46b80-2873">必须的。</span><span class="sxs-lookup"><span data-stu-id="46b80-2873">Required.</span></span> <span data-ttu-id="46b80-2874">包含任何有效文件数的 <see langword="Integer" /> 表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2874">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="46b80-2875">可选。</span><span class="sxs-lookup"><span data-stu-id="46b80-2875">Optional.</span></span> <span data-ttu-id="46b80-2876">要写入文件的一个或多个由逗号分隔的表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2876">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="46b80-2877">将数据写入一个顺序文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2877">Writes data to a sequential file.</span></span> <span data-ttu-id="46b80-2878">通常使用 <see langword="Input" /> 从文件中读取使用 <see langword="Write" /> 编写的数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2878">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="46b80-2879">`Write`和`WriteLine`函数提供用于向后兼容性，并且可能会影响性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2879">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="46b80-2880">对于非旧式应用程序，`My.Computer.FileSystem`对象提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="46b80-2880">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="46b80-2881">有关详细信息，请参阅[使用 Visual Basic 文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。</span><span class="sxs-lookup"><span data-stu-id="46b80-2881">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="46b80-2882">如果省略`Output`，向文件打印一个空行。</span><span class="sxs-lookup"><span data-stu-id="46b80-2882">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="46b80-2883">可以用逗号分隔多个表达式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2883">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="46b80-2884">与不同`Print`函数，`Write`函数插入项与字符串周围的引号之间的逗号，按它们写入到文件的形式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2884">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="46b80-2885">无需显式分隔符放入列表。</span><span class="sxs-lookup"><span data-stu-id="46b80-2885">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="46b80-2886">当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。</span><span class="sxs-lookup"><span data-stu-id="46b80-2886">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="46b80-2887">下面的通用假设遵循这样的数据始终能够阅读和使用正确的解释`Input`，而不考虑区域设置：</span><span class="sxs-lookup"><span data-stu-id="46b80-2887">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="46b80-2888">使用句点作为小数分隔符始终写入数值数据。</span><span class="sxs-lookup"><span data-stu-id="46b80-2888">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="46b80-2889">有关`Boolean`数据，`#TRUE#`或`#FALSE#`打印。</span><span class="sxs-lookup"><span data-stu-id="46b80-2889">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="46b80-2890">`True`和`False`无论区域设置如何，都不翻译关键字。</span><span class="sxs-lookup"><span data-stu-id="46b80-2890">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="46b80-2891">日期数据写入到使用的通用日期格式的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2891">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="46b80-2892">时的日期或时间组件缺失或为零时，仅提供部分是写入文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2892">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="46b80-2893">执行任何操作写入文件，如果`Output`数据为空。</span><span class="sxs-lookup"><span data-stu-id="46b80-2893">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="46b80-2894">但是，对于 null 数据一样，`#NULL#`写入。</span><span class="sxs-lookup"><span data-stu-id="46b80-2894">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="46b80-2895">有关`Error`数据，输出将显示为`#ERROR errorcode#`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2895">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="46b80-2896">`Error`不转换关键字，而不考虑区域设置。</span><span class="sxs-lookup"><span data-stu-id="46b80-2896">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="46b80-2897">`WriteLine` 将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2897">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="46b80-2898">可以在字符串中嵌入引号引起来通过使用双引号括起来，或""。</span><span class="sxs-lookup"><span data-stu-id="46b80-2898">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="46b80-2899">例如，应用于对象的</span><span class="sxs-lookup"><span data-stu-id="46b80-2899">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="46b80-2900">返回的值的字符串`Double quotation marks aren't "difficult" to handle`。</span><span class="sxs-lookup"><span data-stu-id="46b80-2900">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="46b80-2901">通过使用对文件进行写入`Write`或`WriteLine`函数需要`Append`从访问`FileIOPermissionAccess`枚举。</span><span class="sxs-lookup"><span data-stu-id="46b80-2901">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="46b80-2902">有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。</span><span class="sxs-lookup"><span data-stu-id="46b80-2902">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="46b80-2903">此示例使用`Write`函数以将原始数据写入到顺序的文件。</span><span class="sxs-lookup"><span data-stu-id="46b80-2903">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>