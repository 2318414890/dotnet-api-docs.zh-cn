<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="698d4c7779138119bfe452e95602b55a06711e5b" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37712139" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此模块支持的 Visual Basic 语言关键字和访问文件和文件夹的运行时库成员。  
  
   
  
## Examples  
 此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder. <c>Path</c> may include the drive. If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</param>
        <summary>Changes the current directory or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`函数更改默认目录，但不是在默认驱动器。 例如，如果默认驱动器为 C，以下语句更改驱动器 D 上的默认目录，但 C 仍保留默认的驱动器：  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 您可以进行相对目录更改为通过键入两个句点，如下所示：  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`函数需要非托管的代码权限，这可能会影响在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>和。  
  
   
  
## Examples  
 此示例使用`ChDir`函数来更改当前目录或文件夹。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is empty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Changes the current drive.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函数需要非托管代码的权限，这可能会影响其在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用`ChDrive`函数来更改当前驱动器。 如果驱动器不存在，该函数将引发异常。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Required. String expression that specifies an existing drive. If you supply a zero-length string (""), the current drive does not change. If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</param>
        <summary>Changes the current drive.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函数需要非托管代码的权限，这可能会影响其在部分信任情况下执行。 有关详细信息，请参阅<xref:System.Security.Permissions.SecurityPermission>并[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用`ChDrive`函数来更改当前驱动器。 如果驱动器不存在，该函数将引发异常。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Invalid drive is specified, or drive is unavailable.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`CurDir`函数以返回当前路径。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Optional. <see langword="Char" /> expression that specifies an existing drive. If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</param>
        <summary>Returns a string representing the current path. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />. For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>A string representing the current path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`CurDir`函数以返回当前路径。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 `VbVolume` 返回而不是特定文件名的驱动器卷标。  
  
 必须提供`PathName`第一次调用`Dir`函数。 若要检索的下一项，你可以后续调用`Dir`不带参数的函数。  
  
> [!IMPORTANT]
>  若要正确运行，`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>并<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>标志的<xref:System.Security.Permissions.FileIOPermission>要对其授予对执行代码。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，并[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|默认。 指定文件而无需属性。|  
|`ReadOnly`|`vbReadOnly`|指定只读文件，以及文件而无需属性。|  
|`Hidden`|`vbHidden`|指定隐藏的文件，以及文件而无需属性。|  
|`System`|`vbSystem`|指定系统文件以及文件而无需属性。|  
|`Volume`|`vbVolume`|指定卷标签;如果指定任何其他属性，则`vbVolume`将被忽略。|  
|`Directory`|`vbDirectory`|指定目录或文件夹，以及文件而无需属性。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举所指定的 Visual Basic 语言并可以在任意位置而不是实际值在代码中。  
  
   
  
## Examples  
 此示例使用`Dir`函数检查是否存在某些文件和目录。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Optional. <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label. A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">Optional. Enumeration or numeric expression whose value specifies file attributes. If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</param>
        <summary>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</summary>
        <returns>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir`函数支持多个字符的使用 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 `VbVolume` 返回而不是特定文件名的驱动器卷标。  
  
 必须提供`PathName`第一次调用`Dir`函数。 若要检索的下一项，你可以后续调用`Dir`不带任何参数的函数。  
  
> [!IMPORTANT]
>  若要正确运行，`Dir`函数需要<xref:System.Security.Permissions.FileIOPermissionAccess.Read>并<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>标志的<xref:System.Security.Permissions.FileIOPermission>要对其授予对执行代码。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermission>， <xref:System.Security.SecurityException>，并[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbnormal`|默认。 指定不具有任何特性的文件。|  
|`ReadOnly`|`vbReadOnly`|指定只读文件，除了不具有任何特性的文件。|  
|`Hidden`|`vbHidden`|指定隐藏的文件，除了不具有任何特性的文件。|  
|`System`|`vbSystem`|指定系统文件，除了不具有任何特性的文件。|  
|`Volume`|`vbVolume`|指定卷标签;如果指定任何其他属性，则`vbVolume`将被忽略。|  
|`Directory`|`vbDirectory`|指定目录或文件夹，以及不具有任何特性的文件。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举所指定的 Visual Basic 语言，并可以代替实际值在代码中任意位置使用。  
  
   
  
## Examples  
 此示例使用`Dir`函数检查是否存在某些文件和目录。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains any valid file number.</param>
        <summary>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</summary>
        <returns>Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`EOF`以避免通过尝试获取输入文件的末尾而产生的错误。  
  
 `EOF`函数返回`False`直到达到文件末尾。 使用文件打开以进行`Random`或`Binary`访问权限，`EOF`返回`False`直到最后一个执行`FileGet`函数不能读取完整记录。  
  
 使用文件打开以进行`Binary`访问，请尝试通过文件使用读取`Input`直到函数`EOF`返回`True`生成一个错误。 使用`LOF`并`Loc`函数而不是`EOF`使用二进制文件中读取时`Input`，或使用`Get`时使用`EOF`函数。 使用文件打开以进行`Output`，`EOF`始终返回`True`。  
  
   
  
## Examples  
 此示例使用`EOF`函数来检测文件的末尾。 此示例假定`Testfile`是一个文本文件，其中包含若干行文本。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. <see langword="Integer" />. Any valid file number.</param>
        <summary>Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</summary>
        <returns>The following enumeration values indicate the file access mode:  <list type="table"><item><term> Value  </term><description> Mode  </description></item><item><term> 1  </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函数返回一个枚举，表示使用打开的文件的文件模式`FileOpen`函数。  
  
   
  
## Examples  
 此示例使用`FileAttr`函数以返回打开的文件的文件模式。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Optional. Parameter array of 0 or more channels to be closed.</param>
        <summary>Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function. <see langword="My" /> gives you better productivity and performance in file I/O operations. See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[如何： 使用 StreamReader 文件中读取文本](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)，[如何： 使用 StreamWriter 向文件写入文本](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)，和[演练： 中操作文件和目录Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)。  
  
 如果省略`FileNumbers`，打开的所有活动文件`FileOpen`函数将关闭。  
  
 当您关闭已打开的文件`Output`或`Append`，最终输出缓冲区写入到该文件的操作系统缓冲区。 所有关联的缓冲区空间使用的已关闭发布文件。  
  
 当`FileClose`执行函数，而其文件的文件的关联数字结束。  
  
   
  
## Examples  
 此示例使用`FileClose`函数来关闭文件打开以进行`Input`。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Required. <see langword="String" /> expression that specifies the name of the file to be copied. <c>Source</c> may include the directory or folder, and drive, of the source file.</param>
        <param name="Destination">Required. <see langword="String" /> expression that specifies the destination file name. <c>Destination</c> may include the directory or folder, and drive, of the destination file.</param>
        <summary>Copies a file. The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />. See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果尝试使用`FileCopy`函数上当前打开的文件，就会出错。  
  
 `FileCopy` 需要完全信任才能在本地驱动器上工作。  
  
   
  
## Examples  
 此示例使用`FileCopy`函数将一个文件复制到另一个。 在此示例中，假定`SrcFile`是包含数据的文件。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</exception>
        <exception cref="T:System.IO.IOException">File is already open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Date" /> value that indicates the date and time a file was written to. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>
          <see langword="Date" /> value that indicates the date and time a file was created or last modified.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`FileDateTime`函数来确定的日期和时间文件已创建或上次修改时间。 日期和时间显示格式基于系统的区域设置。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常写入到一个文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常写入到一个文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符。 然后，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常写入到一个文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常写入到一个文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte descriptor for the string that describes the length. The default is <see langword="False" />.</param>
        <summary>Reads data from an open disk file into a variable. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGet`通常通过使用写入到文件`FilePut`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或最后一个字节`FileGet`或`FilePut`函数 (或指向的最后一个`Seek`函数) 中读取。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGet`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与读取的数据的长度匹配。  
  
-   默认情况下，如果变量是一个字符串，`FileGet`读取一个双字节说明符的包含的字符串长度，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度字符串;在放到文件，则不写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量是一个数组，可以选择是否要读取的大小和维数的数组说明符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在数组读取时，必须以匹配数组写入的方式。 如果它与描述符写入数组时，您必须读取描述符。 如果未使用说明符，大小和边界的数组传递到`FileGet`确定要读取的内容。  
  
     描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 个字节分配，如下所示：  
  
    -   描述符的 18 个字节: (2 + 8 * 2)  
  
    -   200 个字节的数据: (5 * 10 * 4)。  
  
-   如果读入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FileGet`只读取变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于所读取的数据的长度。  
  
-   `FileGet` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePut`) 通过其长度等于 2 加上 8 倍的维度数的描述符作为前缀: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素所需的所有字节之和。 这包括任何数组和其描述符。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGet` 连续; 从磁盘读取所有变量也就是说，而不填充记录之间。  
  
-   对于在结构中，数组以外的任何数组`FileGet`只读取数据。 未不读取任何说明符。  
  
-   `FileGet` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
    > [!IMPORTANT]
    >  通过使用从文件中读取`FileGet`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name into which data is read.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</param>
        <summary>Reads data from an open disk file into a variable.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject`而不是使用函数`FileGet`以在编译时避免出现多义性，如果类型`Object`返回而不是另一种类型，如`Integer`， `Long`， `Short`，依次类推。  
  
 如果你想要将写出`Variant`类型，`FileGetObject`是必需的。 如果你使用某个对象作为第二个参数，如有疑问，始终建议你使用`FilePutObject`和`FileGetObject`。  
  
 `FileGetObject` 仅在中有效`Random`和`Binary`模式。  
  
 与读取的数据`FileGetObject`通常与编写`FilePutObject`。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`，`FileGetObject`上次读取记录号或字节`FileGetObject`或`FilePutObject`函数 (或指向的最后一个`Seek`函数)。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果读取的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FileGetObject`读取的记录长度边界上的后续记录。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能准确地确定填充的数据量，它是已记录的长度与读取的数据的长度匹配一个好办法。  
  
-   如果读入的变量是一个字符串，默认情况下`FileGetObject`读取一个包含字符串长度的双字节说明符，然后读取该变量的数据。 因此，指定的记录长度`RecordLength`子句`FileOpen`函数必须至少为两个字节大于字符串的实际长度。 Visual Basic 6.0 和早期版本支持固定长度的字符串和读取到文件时，则不会写入长度说明符。 如果你想要读取的字符串，而无需描述符，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果读入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 参数指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 倍的维度数： 2 + 8 * NumberOfDimensions。  
  
     例如，以下数组声明需要 218 个字节时将数组写入到磁盘：  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     分发了 218 个字节，如下所示：为描述符分发了 18 个字节 (2 + 8 * 2)，为数据分发了 100 个字节 (5 * 10 * 4)。  
  
-   `FileGetObject` 只不过是元素之间没有空白，像每个读取时，单独读取元素的结构。 在磁盘上，用户定义类型的动态数组 (使用编写`FilePutObject`) 其长度等于 2 加上 8 倍的维度数的描述符前缀为： 2 + 8 * NumberOfDimensions。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于读取各个元素，包括任何数组和其描述符所需的所有字节之和。 <xref:Microsoft.VisualBasic.VBFixedStringAttribute>类可应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，所有的`Random`规则适用，但以下情况例外：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FileGetObject` 读取所有变量从磁盘连续，也就是说，记录之间没有空白。  
  
-   对于在结构中，数组以外的任何数组`FileGetObject`只读取数据。 未不读取任何说明符。  
  
 `FileGetObject` 读取不是元素的结构不需要双字节长度说明符的可变长度字符串。 读取的字节数等于已中字符串的字符数。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件可能不是 Visual Basic 源文件。  
  
   
  
## Examples  
 下面的示例测试文件中读取一条记录，然后检索它。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file. <c>PathName</c> may include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the length of a file in bytes. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          <see langword="Long" /> value that specifies the length of a file in bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果指定的文件打开时`FileLen`调用函数，返回的值表示它已打开时的文件的大小。  
  
> [!NOTE]
>  若要获取当前打开的文件的长度，请使用`LOF`函数。  
  
   
  
## Examples  
 此示例使用`FileLen`函数以返回文件的长度以字节为单位。 在此示例中，假定`TestFile`是包含一些数据的文件。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">File does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number. Use the <see langword="FreeFile" /> function to obtain the next available file number.</param>
        <param name="FileName">Required. <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</param>
        <param name="Mode">Required. Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</param>
        <param name="Access">Optional. Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />. Defaults to <see langword="ReadWrite" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</param>
        <param name="Share">Optional. Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />. Defaults to <see langword="Lock Read Write" />. For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</param>
        <param name="RecordLength">Optional. Number less than or equal to 32,767 (bytes). For files opened for random access, this value is the record length. For sequential files, this value is the number of characters buffered.</param>
        <summary>Opens a file for input or output. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 可以对其执行任何 I/O 操作之前，必须打开一个文件。 `FileOpen` 对文件的 I/O 分配缓冲区，并确定要使用缓冲区的访问模式。  
  
> [!IMPORTANT]
>  写入到文件时，应用程序可能需要创建一个文件，如果尝试写入的文件不存在。 若要执行此操作，必须在其中创建文件的目录的权限。 但是，如果指定的文件`FileName`确实存在，应用程序需求`Write`仅对文件本身的权限。 可能的为了提高安全性，任何位置创建文件在部署和授予过程`Write`权限到该文件唯一，而不是整个目录。 为了提高安全性，请将数据写入到的根目录或 Program Files 目录而不是用户目录中。  
  
 若要打开的通道可在使用`FreeFile()`函数。  
  
> [!IMPORTANT]
>  `FileOpen`函数需要`Read`从访问`FileIOPermissionAccess`枚举，它可能会影响它在部分信任情况下执行。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例演示了的各种用法`FileOpen`函数，以使输入和输出到文件。  
  
 以下代码打开文件`TestFile`在`Input`模式。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 此示例打开中的文件`Binary`进行只写操作的模式。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 下面的示例打开中的文件`Random`模式。 该文件包含的记录是结构`Person`。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 此代码示例将打开的文件中`Output`模式; 任何进程可以读取或写入文件。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 此代码示例将打开的文件中`Binary`模式进行读取; 其他进程无法读取文件。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Record length is negative (and not equal to -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <param name="ArrayIsDynamic">Optional. Applies only when writing an array. Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</param>
        <param name="StringIsFixedLength">Optional. Applies only when writing a string. Specifies whether to write a two-byte string length descriptor for the string to the file. The default is <see langword="False" />.</param>
        <summary>Writes data from a variable to a disk file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`下, 一步的记录或后的最后一个字节`FileGet`或`FilePut`函数或指向的最后一个`Seek`编写函数。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePut` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePut`，您只需使用相同`FileGet`，您必须确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePut`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能与任何颇有自信地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是一个字符串，`FilePut`将写入一个双字节说明符，包含字符串长度，然后写入该变量的数据。 因此，指定的记录长度`RecordLength`子句中的`FileOpen`函数必须至少为两个字节大于字符串的实际长度。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePut`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePut`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePut`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量是一个数组，则必须选择要写入大小和数组的维数的说明符。 Visual Basic 6.0 和早期版本编写的文件说明符有关的动态数组而不是固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符，设置`ArrayIsDynamic`参数`True`。 在编写数组时，必须匹配的方法将读取该数组;如果它将读取与描述符，您必须写入描述符。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入数组数据和数组描述符需要的所有字节之和。 例如，以下数组声明需要 218 个字节时将数组写入到磁盘。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 （不可变长度字符串或对象）`FilePut`只写入变量数据。 指定的记录长度`RecordLength`子句中的`FileOpen`函数必须是大于或等于写入的数据的长度。  
  
-   `FilePut` 将元素的结构写入像分别，写入的每个元素之间没有空白的情况除外。 `VBFixedString`特性可以应用于字符串字段中的结构，以指示字符串写入时的大小到磁盘。  
  
    > [!NOTE]
    >  字符串字段大小超过指定值的字节`VBFixedString`属性将被截断时写入到磁盘，  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，大部分`Random`模式规则适用，有一些例外情况。 在中打开文件的以下规则`Binary`模式不同于为规则`Random`模式：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePut` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
-   对于在结构中，数组以外的任何数组`FilePut`只写入数据。 未不写入任何说明符。  
  
-   `FilePut` 不是元素的结构，无需两个字节的长度说明符写入可变长度字符串。 写入的字节数等于字符串中的字符数。 例如，以下语句将 11 个字节写入文件号 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   通过使用对文件进行写入`FilePut`函数需要`Write`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入到一个文件。 结构的五个记录`Person`写入到文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</exception>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Valid variable name that contains data written to disk.</param>
        <param name="RecordNumber">Optional. Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</param>
        <summary>Writes data from a variable to a disk file.  The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject`而不是使用函数`FilePut`以在编译时避免出现多义性，如果类型`Object`传递而不是另一种类型，如`Integer`， `Long`， `Short`，依次类推。  
  
 `FilePutObject` 将写入和读取描述该对象的描述符。 如果你想要将写出`Variant`类型，`FilePutObject`是必需的。 如果你使用某个对象作为第二个参数，如有疑问，我们建议始终使用`FilePutObject`和`FileGetObject`。  
  
 `FilePutObject` 仅在中有效`Random`和`Binary`模式。  
  
 通常使用 `FileGetObject` 从文件中读取使用 `FilePutObject` 编写的数据。  
  
 第一个记录或文件中的字节位置 1，第二个记录或字节在位置 2，依此类推。 如果省略`RecordNumber`，`FilePutObject`上次写入下一个记录或字节`FileGetObject`或`FilePutObject`函数 (或记录号或字节指向由最后一个`Seek`函数)。  
  
 `StringIsFixedLength`参数控制函数是否将字符串解释为变量或固定长度。 `FilePutObject` 当参数是不会写入长度说明符`True`。 如果您使用`StringIsFixedLength`  =  `True`与`FilePutObject`，您只需使用相同`FileGetObject`，您必须还需确保该字符串将初始化为所需的长度。  
  
## <a name="random-mode"></a>随机模式  
 有关在中打开文件`Random`模式下，下列规则适用：  
  
-   如果写入的数据的长度小于中指定的长度`RecordLength`子句`FileOpen`函数，`FilePutObject`将后续的记录写入记录长度边界上。 用文件缓冲区的现有内容填充一条记录的末尾和下一条记录的开始之间的空间。 由于不能准确地确定填充的数据量，它通常是最好使记录的长度与写入的数据的长度匹配。 如果写入的数据的长度大于中指定的长度`RecordLength`子句`FileOpen`函数，将引发异常。  
  
-   如果写入的变量是包含一个数值类型的对象`FilePutObject`标识的两个字节写入`VarType`的对象，然后将该变量。 例如，编写一个对象时包含一个整数`FilePutObject`写入 6 个字节： 标识作为对象的两个字节`VarType(3)`(`Integer`) 和包含的数据的四个字节。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少为两个字节大于实际存储在变量所需的字节数。  
  
-   如果写入的变量是一个对象，包含一个字符串，`FilePutObject`写入一个双字节说明符标识`VarType(8)`的对象，然后。 指定的记录长度`RecordLength`中的参数`FileOpen`函数必须至少大于字符串的实际长度为四个字节。 如果你想要放入而无需描述符字符串，则应传递`True`到`StringIsFixedLength`参数，并应为正确的长度，读取到的字符串。  
  
-   如果写入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 子句指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定秩的数组、 大小和为每个级别的下限。 其长度等于 2 + 8 时间维度的数目: (2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>二进制模式  
 打开的文件中`Binary`模式下，所有`Random`模式规则适用，除外：  
  
-   `RecordLength`子句中的`FileOpen`函数不起任何作用。 `FilePutObject` 所有将变量写入磁盘连续，也就是说，不带记录之间的填充。  
  
   
  
## Examples  
 此示例使用`FilePutObject`函数以将字符串写入文件。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="RecordWidth">Required. Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started. If <c>RecordWidth</c> equals 0, there is no limit to the length of a line. The default value for <c>RecordWidth</c> is 0.</param>
        <summary>Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`FileWidth`函数设置文件的输出线条宽度。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</summary>
        <returns>Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FreeFile`提供尚未使用的文件号。  
  
   
  
## Examples  
 此示例使用`FreeFile`函数以返回下一个可用的文件数。 五个文件打开，以便在循环中，输出和一些示例数据写入到每个。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">More than 255 files are in use.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file, directory, or folder name. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:  <list type="table"><item><term> Value  </term><description> Constant  </description><description> Description  </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Read-only.  </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Hidden.  </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System file.  </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directory or folder.  </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> File has changed since last backup.  </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> File has a different name.  </description></item></list><block subset="none" type="note"><para> These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定设置了哪些属性，请使用`And`运算符执行返回的值的按位比较`GetAttr`函数和所需的各个文件属性的值。 如果结果不为零，该属性设置为指定的文件。 例如，下面的返回值`And`表达式是零个 if`Archive`未设置属性：  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 如果返回非零值`Archive`属性设置。  
  
   
  
## Examples  
 此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> is invalid or contains wildcards.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，已使用对其写入数据的某些行`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，已使用对其写入数据的某些行`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Value">Required. Variable that is assigned the values read from the file—cannot be an array or object variable.</param>
        <summary>Reads data from an open sequential file and assigns the data to variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`Input`通常通过使用写入到文件`Write`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
> [!IMPORTANT]
>  当从文件读取，不要确定基于文件扩展名的文件的内容。 例如，名为 form1.vb 的文件可能不是 Visual Basic 2005 源文件。  
  
 读取时，标准字符串或数值数据分配到无需修改的变量。 下表说明了如何处理其他输入的数据。  
  
|数据|分配给变量的值|  
|-|-|  
|分隔逗号或空行|空|  
|#NULL #|`DBNull`|  
|#TRUE # 或 #FALSE #|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|日期和/或表达式表示的时间|  
|#ERROR `errornumber`#|`errornumber` （变量是对象标记为错误）|  
  
 如果在输入数据项目时达到文件末尾，停止输入，并出现错误。  
  
> [!NOTE]
>  `Input`函数未进行本地化。 例如，在德语版，如果输入 3,14159，它返回仅 3，因为逗号视为变量分隔符而不是作为小数点。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`Input`函数需要`Read`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数来从文件读取数据，到两个变量。 此示例假定`TestFile`是一个文件，具有若干行的数据写入到该使用`Write`函数，每行都包含在引用和由逗号分隔，例如一个数字的字符串: ("Hello"，234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="CharCount">Required. Any valid numeric expression specifying the number of characters to read.</param>
        <summary>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`InputString`函数通常通过使用写入到文件`Print`或`FilePut`。 此函数只能用于在打开的文件`Input`或`Binary`模式。  
  
 与不同`Input`函数，`InputString`函数将返回它所读取的所有字符。 这包括逗号、 回车符、 换行符、 引号和前导空格。  
  
 使用文件打开以进行`Binary`访问，请尝试使用通过文件读取`InputString`直到函数`EOF`返回`True`生成一个错误。 使用`LOF`并`Loc`函数而不是`EOF`通过读取二进制文件时`InputString`，或使用`FileGet`当你使用`EOF`函数。  
  
> [!NOTE]
>  当从文件读取，不要根据文件扩展名的文件的内容的安全决策。 例如，名为 form1.vb 的文件可能不是 Visual Basic 源文件。  
  
   
  
## Examples  
 此示例使用`InputString`函数来从文件一次读取一个字符，并将其打印到`Output`窗口。 此示例假定`MyFile`是具有示例数据的多个行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 or &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies one or more file names to be deleted. <c>PathName</c> can include the directory or folder, and the drive.</param>
        <summary>Deletes files from a disk. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` 支持使用多个字符 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 **安全说明**若要执行，`Kill`函数要求`Read`并`PathDiscovery`标志的<xref:System.Security.Permissions.FileIOPermission>要对其授予对执行代码。 有关详细信息，请参阅<xref:System.Security.SecurityException>[代码访问权限](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 此示例使用`Kill`函数从磁盘中删除文件。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Target file(s) open.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Target file(s) not found.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</summary>
        <returns>Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 与读取的数据`LineInput`通常通过使用写入到文件`Print`。  
  
> [!IMPORTANT]
>  时从文件读取，不要根据文件扩展名的文件的内容的决策。 例如，名为 form1.vb 的文件不可能的 Visual Basic 源代码文件。  
  
 `LineInput`函数从文件中的一个字符读取一次直到它遇到回车符 (`Chr(13)`) 或回车符/换行符 (`Chr(13) + Chr(10)`) 序列。 回车/换行符序列将跳过而不是追加到字符字符串。  
  
> [!IMPORTANT]
>  通过使用从文件中读取`LineInput`函数需要`Read`从访问<xref:System.Security.Permissions.FileIOPermissionAccess>枚举。  
  
   
  
## Examples  
 此示例使用`LineInput`函数来从顺序文件中读取一行，并将其分配给一个变量。 此示例假定`TestFile`是具有示例数据的多个行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">End of file reached.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid <see langword="Integer" /> file number.</param>
        <summary>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</summary>
        <returns>Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`函数是从零开始的使用它来检索文件中的第一个字节将返回 0。  
  
 `Loc`提供函数是为了向后兼容，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 下面介绍每种文件访问模式的返回值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入到文件中的最后一个记录的数目。|  
|`Sequential`|除以 128 文件中的当前字节位置。 但是，返回的信息`Loc`的顺序文件不是使用也不需要。|  
|`Binary`|读取或写入的最后一个字节的位置。|  
  
   
  
## Examples  
 此示例使用`Loc`函数以返回打开的文件中的当前读/写位置。 此示例假定`MyFile`是具有示例数据的多个行的文本文件。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FileLen`函数以获取未打开的文件的长度。  
  
   
  
## Examples  
 此示例使用`LOF`函数来确定打开的文件的大小。 此示例假定`TestFile`是一个文本文件，其中包含示例数据。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory to be created. The <c>Path</c> may include the drive. If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</param>
        <summary>Creates a new directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />. For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函数创建一个新目录。  
  
   
  
## Examples  
 此示例使用`MkDir`函数来创建一个目录。 如果未指定驱动器，则当前驱动器上创建新目录。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.Security.SecurityException">Permission denied.</exception>
        <exception cref="T:System.IO.IOException">Directory already exists.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函数是为了向后兼容性，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包括换行符末尾的行;但是，`PrintLine`包括换行符。  
  
 与写入的数据`Print`从文件通常通过使用读取`LineInput`或`Input`。  
  
 如果省略`Output`有关`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。 用逗号分隔的多个表达式将对齐选项卡边界，但混合使用逗号和`TAB`可能会导致不一致的结果。  
  
 有关`Boolean`数据，而是`True`或`False`打印。 `True`和`False`不转换关键字，而不考虑区域设置。  
  
 日期数据写入该文件使用您的系统所识别的标准的短日期格式。 当日期或时间部分缺失或为零时，仅提供部分写入文件。  
  
 执行任何操作写入到文件，如果`Output`数据为空。 但是，如果`Output`列表中的数据`DBNull`，`Null`写入到文件。  
  
 有关`Error`数据，输出将显示为`Error errorcode`。 `Error`关键字不会转换而不考虑区域设置。  
  
 通过使用写入到文件的所有数据`Print`是国际上通用的; 即，数据的正确格式使用相应的小数分隔符。 如果用户想要输出以供多个区域设置数据`Write`应使用。  
  
 通过使用对文件进行写入`Print`或`PrintLine`函数要求`Write`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Print`和`PrintLine`函数将数据写入到一个文件。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Output">Optional. Zero or more comma-delimited expressions to write to a file.  The <c>Output</c> argument settings are:  <see langword="T:System.IO.IOException" />: File mode is invalid.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</param>
        <summary>Writes display-formatted data to a sequential file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print`和`PrintLine`函数是为了向后兼容性，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print` 不包括换行符末尾的行;但是，`PrintLine`包括换行符。  
  
 与写入的数据`Print`从文件通常通过使用读取`LineInput`或`Input`。  
  
 如果省略`Output`有关`PrintLine`，该文件; 有关打印一个空行`Print`，没有输出。 用逗号分隔的多个表达式将对齐选项卡边界，但混合使用逗号和`TAB`可能会导致不一致的结果。  
  
 有关`Boolean`数据，而是`True`或`False`打印。 `True`和`False`不转换关键字，而不考虑区域设置。  
  
 日期数据写入文件，通过使用系统所识别的标准的短日期格式。 当日期或时间部分缺失或为零时，仅提供部分写入文件。  
  
 执行任何操作写入到文件，如果`Output`数据为空。 但是，如果`Output`列表中的数据`DBNull`，`Null`写入到文件。  
  
 有关`Error`数据，输出将显示为`Error errorcode`。 `Error`关键字不会转换而不考虑区域设置。  
  
 通过使用写入到文件的所有数据`Print`是国际上通用的; 即，数据的正确格式使用相应的小数分隔符。 如果用户想要输出以供多个区域设置数据`Write`应使用。  
  
 通过使用对文件进行写入`Print`或`PrintLine`函数要求`Write`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Print`和`PrintLine`函数将数据写入到一个文件。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Required. <see langword="String" /> expression that specifies the existing file name and location. <c>OldPath</c> may include the directory, and drive, of the file.</param>
        <param name="NewPath">Required. <see langword="String" /> expression that specifies the new file name and location. <c>NewPath</c> may include directory and drive of the destination location. The file name specified by <c>NewPath</c> cannot already exist.</param>
        <summary>Renames a disk file or directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename`函数重命名文件，并将其移动到另一个目录，如有必要。 `Rename`函数可以将一个文件，在驱动器，但它只能重命名现有目录时同时`NewPath`和`OldPath`位于同一驱动器上。 `Rename` 无法创建新文件或目录。  
  
 使用`Rename`函数对打开的文件会产生错误。 重命名之前，必须关闭打开的文件。 `Rename` 参数不能包含多个字符 （*） 和单字符 （？） 通配符。  
  
> [!IMPORTANT]
>  当使用`Rename`将文件从受保护的位置复制到受保护的位置，则文件，将保留不太受限制的权限。 检查以确保没有引入可能的安全风险。  
  
   
  
## Examples  
 此示例使用`Rename`函数重命名文件。 对于此示例中，假定已指定的目录存在。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Path is invalid.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> file does not exist.</exception>
        <exception cref="T:System.IO.IOException">Cannot rename to different device.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes all disk files opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset`函数将关闭打开的所有活动文件`FileOpen`函数，并具有相同的功能`FileClose()`不带任何参数。  
  
   
  
## Examples  
 此示例使用`Reset`函数来关闭所有打开的文件，并将所有文件缓冲区的内容写入到磁盘。 请注意，使用`Object`变量`FileNumber`作为一个字符串和数字。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Required. <see langword="String" /> expression that identifies the directory or folder to be removed. <c>Path</c> can include the drive. If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</param>
        <summary>Removes an existing directory. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />. For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你尝试使用出错`RmDir`上包含文件的目录。 使用`Kill`函数删除所有文件，再尝试删除一个目录。  
  
   
  
## Examples  
 此示例使用`RmDir`函数来删除现有目录。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> is not specified or is empty.</exception>
        <exception cref="T:System.IO.IOException">Target directory contains files.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Directory does not exist.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 返回 1 和 2,147,483,647 之间的值 (等效于 2 ^31-1)，非独占。  
  
 下面介绍每个文件访问模式的返回的值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入的下一个记录的数目|  
|`Binary`, `Input`, `Output`, `Append`|下一步操作发生的字节位置。 在文件中的第一个字节位于位置 1，第二个字节在位置 2，依此类推。|  
  
   
  
## Examples  
 此示例使用`Seek`函数以返回当前文件位置。 该示例假定`TestFile`是包含记录的结构的一个文件`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 打开的文件中`Random`模式下，`Seek`返回下一条记录的数目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 而不在模式下打开的文件`Random`模式下，`Seek`返回下一步操作发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 此示例使用`Seek`函数将位置设置为下一次读取或写入的文件中。  
  
 而不在模式下打开的文件`Random`模式下，`Seek`设置下一步操作发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> that contains a valid file number.</param>
        <param name="Position">Required. Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</param>
        <summary>Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` 返回 1 和 2,147,483,647 之间的值 (等效于 2 ^31-1)，非独占。  
  
 下面介绍每个文件访问模式的返回的值：  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入的下一个记录的数目|  
|`Binary`, `Input`, `Output`, `Append`|下一步操作发生的字节位置。 在文件中的第一个字节位于位置 1，第二个字节在位置 2，依此类推。|  
  
   
  
## Examples  
 此示例使用`Seek`函数以返回当前文件位置。 该示例假定`TestFile`是包含记录的结构的一个文件`Record`。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 打开的文件中`Random`模式下，`Seek`返回下一条记录的数目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 而不在模式下打开的文件`Random`模式下，`Seek`返回下一步操作发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 此示例使用`Seek`函数将位置设置为下一次读取或写入的文件中。  
  
 而不在模式下打开的文件`Random`模式下，`Seek`设置下一步操作发生的字节位置。 假定`TestFile`是包含若干行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Required. <see langword="String" /> expression that specifies a file name. <c>PathName</c> can include directory or folder, and drive.</param>
        <param name="Attributes">Required. Constant or numeric expression, whose sum specifies file attributes.</param>
        <summary>Sets attribute information for a file. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您尝试设置打开的文件的属性，会发生运行时错误。  
  
 `Attributes`参数枚举值如下所示：  
  
|“值”|返回的常量|描述|  
|-|-|-|  
|`Normal`|`vbNormal`|正常 （默认值）。|  
|`ReadOnly`|`vbReadOnly`|只读。|  
|`Hidden`|`vbHidden`|隐藏。|  
|`System`|`vbSystem`|系统文件。|  
|`Volume`|`vbVolume`|卷标|  
|`Directory`|`vbDirectory`|目录或文件夹。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  由 Visual Basic 语言指定这些枚举。 名称可以是任意位置在代码中使用而不是实际值。  
  
   
  
## Examples  
 此示例使用`SetAttr`函数设置的文件的属性。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> type is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Required. The number of spaces to insert before displaying or printing the next expression in a list.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Count`小于输出行宽下, 一个输出位置立即遵循打印的空格数。 如果`Count`大于输出行宽，`SPC`计算使用的公式的下一步打印位置：  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 例如，如果当前输出位置为 24，输出行的宽度为 80，并指定`SPC(90)`下, 一步的输出将从开始位置 34 （当前打印位置 + 90/80 的其余部分）。 如果当前的输出位置和输出行宽度之间的区别是小于`Count`(或`Count` `Mod` *宽度*)，则`SPC`函数将跳至下一行，并生成空间等于`Count`– (*宽度*–*小于*)。  
  
> [!NOTE]
>  请确保表格列的宽度足以允许较宽的字母。  
  
   
  
## Examples  
 此示例使用`SPC`函数以定位输出文件中并在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前行上的当前打印位置大于`Column`，`TAB`将跳到列的值等于`Column`下一步的输出行上。 如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。 如果`Column`大于输出行宽，`TAB`计算使用的公式的下一步打印位置：  
  
 Mod 列宽  
  
 例如，如果*宽度*是 80，并指定`TAB(90)`下, 一步的输出将从开始第 10 （90/80 的余数） 列。 如果`Column`小于当前打印位置，开始计算的输出位置的下一行上。 如果计算出的打印位置大于当前打印位置，打印开始计算打印位置在同一行。  
  
 输出行上最左侧的打印位置始终为 1。 当你使用`Print`或`PrintLine`函数来打印到文件，右侧的输出位置是输出文件，您可以使用设置的当前宽度`FileWidth`函数。  
  
 `TAB`函数也可以用于`WriteLine`函数。 它不能用于<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  请确保表格列的宽度足以包含较宽的字母。  
  
   
  
## Examples  
 此示例使用`TAB`函数以定位输出文件中并在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</param>
        <summary>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</summary>
        <returns>Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前行上的当前打印位置大于`Column`，`TAB`将跳到列的值等于`Column`下一步的输出行上。 如果`Column`小于 1，`TAB`将打印位置移动到第 1 列。 如果`Column`大于输出行宽，`TAB`计算使用的公式的下一步打印位置：  
  
 Mod 列宽  
  
 例如，如果*宽度*是 80，并指定`TAB(90)`下, 一步的输出将从开始第 10 （90/80 的余数） 列。 如果`Column`小于当前打印位置，开始计算的输出位置的下一行上。 如果计算出的打印位置大于当前打印位置，打印开始计算打印位置在同一行。  
  
 输出行上最左侧的打印位置始终为 1。 当你使用`Print`或`PrintLine`函数来打印到文件，右侧的输出位置是输出文件，您可以使用设置的当前宽度`FileWidth`函数。  
  
 `TAB`函数也可以用于`WriteLine`函数。 它不能用于<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>。  
  
> [!NOTE]
>  请确保表格列的宽度足以包含较宽的字母。  
  
   
  
## Examples  
 此示例使用`TAB`函数以定位输出文件中并在**输出**窗口。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="Record">Optional. Number of the only record or byte to lock or unlock</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. Any valid file number.</param>
        <param name="FromRecord">Optional. Number of the first record or byte to lock or unlock.</param>
        <param name="ToRecord">Optional. Number of the last record or byte to lock or unlock.</param>
        <summary>Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function. The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />. For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock`和`Unlock`函数用于环境中的多个进程可能需要访问同一文件。  
  
 `Lock` 和`Unlock`函数始终成对使用。 参数`Lock`和`Unlock`必须相同。  
  
 如果`Record`，或`FromRecord`和`ToRecord`是未提供，该锁将在整个文件。 如果`Record`单独指定单个记录将锁定/解锁。  
  
 如果已打开文件进行连续的输入或输出中，`Lock`并`Unlock`会影响整个文件，而不考虑指定的范围`FromRecord`和`ToRecord`。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含记录的结构的一个文件`Person`。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函数是为了向后兼容性，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果省略`Output`，向文件打印一个空行。 可以用逗号分隔多个表达式。  
  
 与不同`Print`函数，`Write`函数之间插入逗号项和引号将字符串写入该文件。 无需显式分隔符放入列表。 当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。 下面的通用假设遵循这样的数据始终能够阅读和正确解释使用`Input`，无论区域设置：  
  
-   使用句点作为小数分隔符始终写入数值数据。  
  
-   有关`Boolean`数据，而是`#TRUE#`或`#FALSE#`打印。 `True`和`False`不转换关键字，而不考虑区域设置。  
  
-   日期数据写入到使用通用日期格式的文件。 当日期或时间部分缺失或为零时，仅提供部分写入文件。  
  
-   执行任何操作写入到文件，如果`Output`数据为空。 但是，对于 null 数据`#NULL#`写入。  
  
-   有关`Error`数据，输出将显示为`#ERROR errorcode#`。 `Error`不转换关键字，而不考虑区域设置。  
  
 `WriteLine` 将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`的文件。  
  
 您可以通过使用双引号引起来，在字符串中嵌入引号或""。 例如，应用于对象的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 返回一个字符串值为`Double quotation marks aren't "difficult" to handle`。  
  
 通过使用对文件进行写入`Write`或`WriteLine`函数要求`Append`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Write`函数将原始数据写入顺序文件。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">File mode is invalid.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Required. An <see langword="Integer" /> expression that contains any valid file number.</param>
        <param name="Output">Optional. One or more comma-delimited expressions to write to a file.</param>
        <summary>Writes data to a sequential file. Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write`和`WriteLine`函数是为了向后兼容性，可能会影响性能。 对于非旧版应用程序，`My.Computer.FileSystem`对象提供更好的性能。 有关详细信息，请参阅[使用 Visual Basic 访问文件](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果省略`Output`，向文件打印一个空行。 可以用逗号分隔多个表达式。  
  
 与不同`Print`函数，`Write`函数之间插入逗号项和引号将字符串写入该文件。 无需显式分隔符放入列表。 当`Write`用于将数据写入到文件中，仅数字`Boolean`，日期、 null 和`Error`支持数据格式。 下面的通用假设遵循这样的数据始终能够阅读和正确解释使用`Input`，无论区域设置：  
  
-   使用句点作为小数分隔符始终写入数值数据。  
  
-   有关`Boolean`数据，而是`#TRUE#`或`#FALSE#`打印。 `True`和`False`不转换关键字，而不考虑区域设置。  
  
-   日期数据写入到使用通用日期格式的文件。 当日期或时间部分缺失或为零时，仅提供部分写入文件。  
  
-   执行任何操作写入到文件，如果`Output`数据为空。 但是，对于 null 数据`#NULL#`写入。  
  
-   有关`Error`数据，输出将显示为`#ERROR errorcode#`。 `Error`不转换关键字，而不考虑区域设置。  
  
 `WriteLine` 将插入一个换行符 (即回车符/换行符，或`Chr(13) + Chr(10)`)，在其写入的最后一个字符后`Output`的文件。  
  
 您可以通过使用双引号引起来，在字符串中嵌入引号或""。 例如，应用于对象的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 返回一个字符串值为`Double quotation marks aren't "difficult" to handle`。  
  
 通过使用对文件进行写入`Write`或`WriteLine`函数要求`Append`从访问`FileIOPermissionAccess`枚举。 有关详细信息，请参阅<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Write`函数将原始数据写入顺序文件。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>