<Type Name="Collection" FullName="Microsoft.VisualBasic.Collection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="db858d535030f701aac72d90bb3cdd8de3417d03" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174023" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Collection : System.Collections.IList, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed Collection extends System.Object implements class System.Collections.ICollection, class System.Collections.IList, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Collection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Collection&#xA;Implements IDeserializationCallback, IList, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Collection sealed : System::Collections::IList, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(Microsoft.VisualBasic.Collection/CollectionDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Visual Basic <see langword="Collection" /> 是可作为单元引用的一组有序项。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  只要可能，您应使用 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空间或 <xref:System.Collections.Concurrent> 命名空间而不是 Visual Basic `Collection` 中的泛型集合。 有关详细信息，请参阅[集合](http://msdn.microsoft.com/library/e76533a9-5033-4a0b-b003-9c2be60d185b)。  
  
 Visual Basic`Collection`对象提供一组作为单个对象相关的项是指一种简便方式。 该项目，或*元素*中只需要相关，因为它们存在于集合的集合。 集合中的元素不需要共享相同的数据类型。  
  
 可以创建集合相同的方式创建其他对象，如下面的示例所示。  
  
```vb  
Dim coll As New Microsoft.VisualBasic.Collection()  
```  
  
 一旦你已创建集合，可以执行以下任一操作：  
  
-   添加具有的元素<xref:Microsoft.VisualBasic.Collection.Add%2A>方法。  
  
-   删除具有的元素<xref:Microsoft.VisualBasic.Collection.Remove%2A>方法。  
  
-   删除具有的所有元素<xref:Microsoft.VisualBasic.Collection.Clear%2A>方法。  
  
-   了解集合包含具有的元素数量<xref:Microsoft.VisualBasic.Collection.Count%2A>属性。  
  
-   检查的特定元素是否存在与<xref:Microsoft.VisualBasic.Collection.Contains%2A>方法。  
  
-   返回集合中具有的特定元素<xref:Microsoft.VisualBasic.Collection.Item%2A>属性。  
  
-   循环访问整个集合[每个...下一条语句](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)。  
  
    > [!NOTE]
    >  尽管 Visual Basic`Collection`对象具有相同的功能`Collection`对象在 Visual Basic 6.0 中，两个无法在 COM 环境进行交互操作。  
  
    > [!CAUTION]
    >  循环访问 Visual Basic`Collection`不是一个线程安全的过程。 即使集合已同步，其他线程仍可以修改集合，从而导致枚举数引发异常。 若要确保枚举过程中的线程安全性，请锁定集合，或者捕获由其他线程进行的更改导致的异常。 锁定编程元素的详细信息，请参阅[SyncLock 语句](~/docs/visual-basic/language-reference/statements/synclock-statement.md)。  
  
   
  
## Examples  
 下面的示例创建`Collection`对象`names`和一个对话框，使用该用户可以向集合添加对象 （名称）。 它然后在集合中，显示名称和最后不必释放的清空集合`Collection`对象本身。  
  
 若要查看此工作原理，请选择**添加类**命令**项目**菜单，并声明调用的公共变量`instanceName`在模块级别的`nameClass`(类型`Public instanceName`) 来保存每个实例的名称。 保留默认名称为`nameClass`。 复制并粘贴下面的代码插入**常规**另一个模块，部分，然后启动它与语句`classNamer`在另一个过程。 （此示例仅适用于托管应用程序支持类。）  
  
 [!code-vb[VbVbalrCollectionObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Collection ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Collection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>创建并返回一个新的 Visual Basic <see cref="T:Microsoft.VisualBasic.Collection" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回此构造函数的 Visual Basic 集合为空，并且没有任何已分配的初始容量。  
  
 Visual Basic 集合不是与兼容[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]集合中提供<xref:System.Collections?displayProperty=nameWithType>， <xref:System.Collections.Generic?displayProperty=nameWithType>，和<xref:System.Collections.Specialized?displayProperty=nameWithType>命名空间。  
  
   
  
## Examples  
 下面的示例创建一个新的 Visual Basic 集合并将其分配给该变量`coll`:  
  
```vb  
Dim coll As New Microsoft.VisualBasic.Collection()  
```  
  
 这`Collection`对象是从一开始，这意味着，从 1 到的值的元素范围的索引值`Count`属性。 Visual Basic 集合会保留类型的元素<xref:System.Object>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object Item, string Key = null, object Before = null, object After = null);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Add(object Item, string Key, object Before, object After) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Add(System.Object,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (Item As Object, Optional Key As String = null, Optional Before As Object = null, Optional After As Object = null)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Item" Type="System.Object" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Before" Type="System.Object" />
        <Parameter Name="After" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Item">必须的。 指定要添加到集合的元素的任意类型的对象。</param>
        <param name="Key">可选。 指定键字符串的唯一 <see langword="String" /> 表达式，可以用此键字符串代替定位索引访问集合的这个新元素。</param>
        <param name="Before">可选。 指定集合中的相对位置的表达式。 将要添加的元素放在集合中由 <c>Before</c> 参数标识的元素前面。 如果 <c>Before</c> 是数值表达式，则它必须是介于 1 和集合的 <see cref="P:Microsoft.VisualBasic.Collection.Count" /> 属性值之间的数值。 如果 <c>Before</c> 是 <see langword="String" /> 表达式，则它必须对应于将引用的元素添加到集合时指定的键字符串。 不能同时指定 <c>Before</c> 和 <c>After</c>。</param>
        <param name="After">可选。 指定集合中的相对位置的表达式。 将要添加的元素放在集合中由 <c>After</c> 参数标识的元素后面。 如果 <c>After</c> 是数值表达式，则它必须是介于 1 和集合的 <see langword="Count" /> 属性值之间的数值。 如果 <c>After</c> 是 <see langword="String" /> 表达式，则它必须对应于将引用的元素添加到集合时指定的键字符串。 不能同时指定 <c>Before</c> 和 <c>After</c>。</param>
        <summary>将一个元素添加到 <see langword="Collection" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Before`或`After`参数必须引用现有元素的集合; 否则，会出现错误。  
  
 如果这两个`Before`和`After`参数将被省略，将新对象添加到集合的末尾。  
  
 如果指定，也会发生错误`Key`值与现有元素的集合的键匹配。  
  
   
  
## Examples  
 下面的示例使用`Add`方法将添加`child`对象-类的实例调用`child`包含`Public`属性`name`-一个名为集合到`family`。 若要查看此工作原理，创建<xref:System.Windows.Forms.Form>包含两个<xref:System.Windows.Forms.Button>控件并设置其<xref:System.Windows.Forms.Control.Text%2A>属性设置为`Add`和`List`。 添加`child`类定义和`family`对窗体代码的声明。 修改`_Click`事件处理程序**添加**和**列表**按钮如下所示。 **添加**按钮允许您添加子级。 **列表**按钮将显示的所有子级的名称。  
  
 [!code-vb[VbVbalrCollectionObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>删除 Visual Basic <see langword="Collection" /> 对象的所有元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Clear`方法可清空集合并将重置其<xref:Microsoft.VisualBasic.Collection.Count%2A>属性设为 0。  
  
   
  
## Examples  
 [!code-vb[VbVbalrCollectionObject#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string Key);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool Contains(string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (Key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ Key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">必须的。 <see langword="String" /> 表达式，指定搜索集合的元素所用的键。</param>
        <summary>返回一个 <see langword="Boolean" /> 值，该值指示 Visual Basic <see langword="Collection" /> 对象是否包含一个带有特定键的元素。</summary>
        <returns>返回一个 <see langword="Boolean" /> 值，该值指示 Visual Basic <see langword="Collection" /> 对象是否包含一个带有特定键的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Contains` 返回`True`如果集合包含具有完全匹配的键的元素`Key`。 否则为`Contains`返回`False`。 密钥值进行匹配时忽略大小写。  
  
 Visual Basic`Collection`可以存放一些具有键的元素和其他没有键的元素。 这取决于是否对的调用<xref:Microsoft.VisualBasic.Collection.Add%2A>方法提供可选的自变量`Key`参数。  
  
   
  
## Examples  
 [!code-vb[VbVbalrCollectionObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#4)]  
  
 如果你想要使用其键的元素在集合中搜索，请记得提供`Key`自变量每次调用时`Add`方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回一个包含集合中的元素数量的 <see langword="Integer" />。 只读。</summary>
        <value>返回一个包含集合中的元素数量的 <see langword="Integer" />。 只读。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`Count`属性来确定中的元素数`Collection`对象。  
  
   
  
## Examples  
 此示例演示如何使用`Count`属性来显示中的元素数<xref:Microsoft.VisualBasic.Collection>变量中的对象`birthdays`。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#6)]  
  
 `Collection`对象是从一开始，这意味着，从 1 到的值的元素范围的索引值`Count`属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个对枚举数对象的引用，该对象用于循环访问 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象。</summary>
        <returns>返回一个对枚举数对象的引用，该对象用于循环访问 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [每个...下一条语句](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)调用`GetEnumerator`若要获取的枚举器对象，用于支持循环访问集合的元素。 通常情况下，使用`For Each`...`Next`循环遍历集合或数组，并且不需要调用`GetEnumerator`显式。  
  
 如果需要进一步控制比迭代`For Each`...`Next`语句提供，你可以使用`GetEnumerator`方法来执行自定义的遍历。 以下是某些情况下，你可能需要执行此操作。  
  
-   你可能想要返回到集合的开头并重新开始迭代之前完成。  
  
-   你可能想要跳过的原因有多种多样的一个或多个元素。  
  
-   你可能需要更改中间遍历集合的元素。 在这种情况下，因为失效前一个，你必须获取新的枚举器对象。  
  
   
  
## Examples  
 下面的示例演示如何使用`GetEnumerator`要从中检索的所有元素`Collection`对象。  
  
 [!code-vb[VbVbalrCollectionObject#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#7)]  
  
 `GetEnumerator` 构造并返回一个枚举器对象，它实现<xref:System.Collections.IEnumerator>界面<xref:System.Collections>命名空间。 枚举器对象公开<xref:System.Collections.IEnumerator.Current%2A>属性和<xref:System.Collections.IEnumerator.MoveNext%2A>和<xref:System.Collections.IEnumerator.Reset%2A>方法。 有关详细信息，请参阅[每个...下一条语句](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>按位置或键返回 <see langword="Collection" /> 对象的特定元素。 只读。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[int Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[int] { System::Object ^ get(int Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">(A) 一个数值表达式，用于指定集合的元素位置。 <c>Index</c> 必须为介于 1 到集合的 <see cref="P:Microsoft.VisualBasic.Collection.Count" /> 属性的值之间的数字。 或 (B) 指定集合中元素的位置或键字符串的 <see langword="Object" /> 表达式。</param>
        <summary>按位置或键返回 <see langword="Collection" /> 对象的特定元素。 只读。</summary>
        <value>按位置或键返回 <see langword="Collection" /> 对象的特定元素。 只读。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Index`属于类型`Object`、`Item`属性尝试将其视为`String`， `Char`，`Char`数组或整数值。 如果`Item`不能转换`Index`到`String`或`Integer`，它将引发<xref:System.ArgumentException>异常。  
  
 `Item`属性是集合的默认属性。 因此，以下代码行是等效的。  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 下面的示例使用`Item`属性来检索集合中对象的引用。 它将创建`birthdays`作为`Collection`对象，然后检索表示帐单的生日，使用密钥的对象`"Bill"`作为`Index`自变量。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 请注意，第一次调用显式指定`Item`属性，但第二个却没有。 这两个调用起作用，因为`Item`属性是其默认属性`Collection`对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">(A) 一个数值表达式，用于指定集合的元素位置。 <c>Index</c> 必须为介于 1 到集合的 <see cref="P:Microsoft.VisualBasic.Collection.Count" /> 属性的值之间的数字。 或 (B) 指定集合中元素的位置或键字符串的 <see langword="Object" /> 表达式。</param>
        <summary>按位置或键返回 <see langword="Collection" /> 对象的特定元素。 只读。</summary>
        <value>按位置或键返回 <see langword="Collection" /> 对象的特定元素。 只读。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Index`属于类型`Object`、`Item`属性尝试将其视为`String`， `Char`，`Char`数组或整数值。 如果`Item`不能转换`Index`到`String`或`Integer`，它将引发<xref:System.ArgumentException>异常。  
  
 `Item`属性是集合的默认属性。 因此，以下代码行是等效的。  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 下面的示例使用`Item`属性来检索集合中对象的引用。 它将创建`birthdays`作为`Collection`对象，然后检索表示帐单的生日，使用密钥的对象`"Bill"`作为`Index`自变量。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 请注意，第一次调用显式指定`Item`属性，但第二个却没有。 这两个调用起作用，因为`Item`属性是其默认属性`Collection`对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[string Key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ Key); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">指定键字符串的唯一 <see langword="String" /> 表达式，可以使用此键字符串代替位置索引访问集合中的元素。 <c>Key</c> 必须对应于将元素添加到集合中时指定的 <c>Key</c> 参数。</param>
        <summary>按位置或键返回 <see langword="Collection" /> 对象的特定元素。 只读。</summary>
        <value>按位置或键返回 <see langword="Collection" /> 对象的特定元素。 只读。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Index`属于类型`Object`、`Item`属性尝试将其视为`String`， `Char`，`Char`数组或整数值。 如果`Item`不能转换`Index`到`String`或`Integer`，它将引发<xref:System.ArgumentException>异常。  
  
 `Item`属性是集合的默认属性。 因此，以下代码行是等效的。  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 下面的示例使用`Item`属性来检索集合中对象的引用。 它将创建`birthdays`作为`Collection`对象，然后检索表示帐单的生日，使用密钥的对象`"Bill"`作为`Index`自变量。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 请注意，第一次调用显式指定`Item`属性，但第二个却没有。 这两个调用起作用，因为`Item`属性是其默认属性`Collection`对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从 <see langword="Collection" /> 对象移除元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(int32 Index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">一个数值表达式，用于指定集合的元素位置。 <c>Index</c> 必须为介于 1 到集合的 <see cref="P:Microsoft.VisualBasic.Collection.Count" /> 属性的值之间的数字。</param>
        <summary>从 <see langword="Collection" /> 对象移除元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当`Remove`从集合中删除元素它递减集合的<xref:Microsoft.VisualBasic.Collection.Count%2A>通过一个属性。 它还递减`Index`先前跟在集合中删除的元素之后的每个元素的值。  
  
 如果元素已添加到集合而无需`Key`，必须使用其`Index`，将其删除。  
  
   
  
## Examples  
 此示例演示如何使用`Remove`方法可以删除对象从<xref:Microsoft.VisualBasic.Collection>变量中的对象`birthdays`。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#9)]  
  
 以下四个调用`Add`方法，`Count`属性包含 4，元素`"Bill"`有索引值为 1，并且元素`"Pete"`的索引值为 4。  
  
 以下首次调用`Remove`，`Count`为 3，元素`"Bill"`被删除，和元素`"Pete"`的索引值为 3。  
  
 以下第二次调用`Remove`，`Count`为 2，元素`"Mike"`被删除，和元素`"Pete"`的索引值为 2。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string Key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Key As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ Key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">指定键字符串的唯一 <see langword="String" /> 表达式，可以使用此键字符串代替位置索引访问集合中的元素。 <c>Key</c> 必须对应于将元素添加到集合中时指定的 <c>Key</c> 参数。</param>
        <summary>从 <see langword="Collection" /> 对象移除元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当`Remove`从集合中删除元素它递减集合的<xref:Microsoft.VisualBasic.Collection.Count%2A>通过一个属性。 它还递减`Index`先前跟在集合中删除的元素之后的每个元素的值。  
  
 如果元素已添加到集合而无需`Key`，必须使用其`Index`，将其删除。  
  
   
  
## Examples  
 此示例演示如何使用`Remove`方法可以删除对象从<xref:Microsoft.VisualBasic.Collection>变量中的对象`birthdays`。  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#9)]  
  
 以下四个调用`Add`方法，`Count`属性包含 4，元素`"Bill"`有索引值为 1，并且元素`"Pete"`的索引值为 4。  
  
 以下首次调用`Remove`，`Count`为 3，元素`"Bill"`被删除，和元素`"Pete"`的索引值为 3。  
  
 以下第二次调用`Remove`，`Count`为 2，元素`"Mike"`被删除，和元素`"Pete"`的索引值为 2。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void ICollectionCopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.ICollectionCopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void ICollectionCopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维 <see cref="T:System.Array" />，它是从 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象复制的元素的目标。 <see cref="T:System.Array" /> 必须具有从零开始的索引。</param>
        <param name="index">
          <c>array</c> 中从零开始的索引，在此处开始复制。</param>
        <summary>从特定的 <see cref="T:Microsoft.VisualBasic.Collection" /> 索引处开始，将 <see cref="T:System.Array" /> 的元素复制到一个 <see cref="T:System.Array" /> 中。 实现 <see cref="T:System.Collections.ICollection" /> 接口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元素被复制到<xref:System.Array>枚举数循环访问的相同顺序<xref:Microsoft.VisualBasic.Collection>对象。  
  
 此方法为 O (`n`) 操作，其中`n`从获取<xref:Microsoft.VisualBasic.Collection.System%23Collections%23ICollection%23Count>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> 是多维的。  - 或 -  源 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中的元素数目大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 末尾之间的可用空间。</exception>
        <exception cref="T:System.InvalidCastException">无法自动将源 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象的类型强制转换为目标 <paramref name="array" /> 的类型。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.ICollectionCount">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.ICollectionCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ICollectionCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionCount" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionCount As Integer Implements ICollection.ICollectionCount" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.ICollectionCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.ICollectionIsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.ICollectionIsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ICollectionIsSynchronized" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionIsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionIsSynchronized As Boolean Implements ICollection.ICollectionIsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.ICollectionIsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.ICollectionSyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.ICollectionSyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ICollectionSyncRoot" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionSyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionSyncRoot As Object Implements ICollection.ICollectionSyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.ICollectionSyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance class System.Collections.IEnumerator ICollectionGetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.ICollectionGetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function ICollectionGetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ ICollectionGetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个循环访问集合的枚举器。 实现 <see cref="T:System.Collections.ICollection" /> 接口。</summary>
        <returns>一个可用于循环访问集合的 <see cref="T:System.Collections.IEnumerator" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic、 C#]  
  
 C# 语言的 `foreach` 语句（在 Visual Basic 中为 `for each`）隐藏了枚举数的复杂性。 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A>方法还会枚举器放回此位置。 在此位置上，<xref:System.Collections.IEnumerator.Current%2A>属性是不确定。 因此，必须调用<xref:System.Collections.IEnumerator.MoveNext%2A>方法将枚举数前移到集合，然后再读取的值的第一个元素<xref:System.Collections.IEnumerator.Current%2A>。  
  
 在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过的末尾的集合，枚举数定位在集合中的最后一个元素的后面和<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举器位于此位置上，后续调用<xref:System.Collections.IEnumerator.MoveNext%2A>还返回`false`。 如果最后一次调用到<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`，<xref:System.Collections.IEnumerator.Current%2A>是不确定的。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 枚举数没有对集合的独占访问权；因此，从头到尾对一个集合进行枚举在本质上不是一个线程安全的过程。 若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。 若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListAdd(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListAdd(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListAdd (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListAdd(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要添加到 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中的 <see cref="T:System.Object" />。</param>
        <summary>向 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象添加项。 实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
        <returns>新元素的插入位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 你还可以使用<xref:Microsoft.VisualBasic.Collection.Item%2A>中不存在要添加新元素的键的值设置属性<xref:Microsoft.VisualBasic.Collection>对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:Microsoft.VisualBasic.Collection" /> 对象是只读的。  - 或 -  <see cref="T:Microsoft.VisualBasic.Collection" /> 对象具有固定大小。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Add(System.Object)" />
        <altmember cref="P:Microsoft.VisualBasic.Collection.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListClear" />
      <MemberSignature Language="VB.NET" Value="Sub IListClear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListClear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中移除所有项。 实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法中移除所有项从<xref:Microsoft.VisualBasic.Collection>对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> 为只读。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.Hashtable.Clear" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance bool IListContains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListContains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListContains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool IListContains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 对象中查找的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <summary>确定 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象是否包含特定值。 实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
        <returns>如果在 <see cref="T:System.Object" /> 对象中找到 <see cref="T:Microsoft.VisualBasic.Collection" />，则返回 <see langword="True" />，否则返回 <see langword="False" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可确定是否<xref:Microsoft.VisualBasic.Collection>对象包含特定值。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IListIsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IListIsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IListIsFixedSize" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListIsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IListIsFixedSize As Boolean Implements IList.IListIsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IListIsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IListIsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IListIsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IListIsReadOnly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListIsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IListIsReadOnly As Boolean Implements IList.IListIsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IListIsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IListItem">
      <MemberSignature Language="C#" Value="object System.Collections.IList.IListItem[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object IListItem(int32)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property IListItem(index As Integer) As Object Implements IList.IListItem" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.IListItem[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListIndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListIndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在 <see cref="T:System.Object" /> 对象中查找的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <summary>确定 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中特定项的索引。 实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
        <returns>如果在集合中找到该对象，则为 <paramref name="value" />；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法确定中特定项的索引<xref:Microsoft.VisualBasic.Collection>对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.IndexOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListInsert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListInsert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub IListInsert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListInsert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">从零开始的索引，应在该位置插入 <c>value</c>。</param>
        <param name="value">要插入到 <see cref="T:System.Object" /> 对象中的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <summary>将项插入 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中的指定索引处。 实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`index`等于的中的项数<xref:Microsoft.VisualBasic.Collection>对象，然后`value`追加到末尾。  
  
 在由连续的元素组成的集合（如列表）中，插入点下面的元素将下移以容纳新的元素。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不是 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:Microsoft.VisualBasic.Collection" /> 对象是只读的。  - 或 -  <see cref="T:Microsoft.VisualBasic.Collection" /> 对象具有固定大小。</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> 在 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中为空引用。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListRemove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListRemove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub IListRemove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListRemove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要从 <see cref="T:System.Object" /> 对象中移除的 <see cref="T:Microsoft.VisualBasic.Collection" />。</param>
        <summary>从 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中移除特定对象的第一个匹配项。 实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在由连续的元素组成的集合（如列表）中，已移除元素下面的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。 如果`value`中找不到<xref:Microsoft.VisualBasic.Collection>对象，<xref:Microsoft.VisualBasic.Collection>对象保持不变且不引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:Microsoft.VisualBasic.Collection" /> 对象是只读的。  - 或 -  <see cref="T:Microsoft.VisualBasic.Collection" /> 对象具有固定大小。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListRemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListRemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub IListRemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListRemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的项的从零开始的索引。</param>
        <summary>移除指定索引处的 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象项。 实现 <see cref="T:System.Collections.IList" /> 接口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在由连续的元素组成的集合（如列表）中，已移除元素下面的元素将上移以占据空出的位置。 如果集合具有索引，则移动的元素的索引也将更新。 此行为不适用于元素按概念划分为不同存储桶的集合，如哈希表。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> 不是 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:Microsoft.VisualBasic.Collection" /> 对象是只读的。  - 或 -  <see cref="T:Microsoft.VisualBasic.Collection" /> 对象具有固定大小。</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">启动回调的对象。</param>
        <summary>在整个 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象图反序列化后运行。 实现 <see cref="T:System.Runtime.Serialization.IDeserializationCallback" /> 接口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在整个之后调用此方法<xref:Microsoft.VisualBasic.Collection>对象图形已经反序列化。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Runtime.Serialization.IDeserializationCallback" />
        <altmember cref="M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象，包含序列化 <see cref="T:Microsoft.VisualBasic.Collection" /> 所需的信息。</param>
        <param name="context">一个 <see cref="T:System.Runtime.Serialization.StreamingContext" /> 对象，它包含与 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象关联的已序列化流的源和目标。</param>
        <summary>返回对 <see cref="T:Microsoft.VisualBasic.Collection" /> 对象进行序列化所需的数据。 实现 <see cref="T:System.Runtime.Serialization.ISerializable" /> 接口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回序列化所需的数据<xref:Microsoft.VisualBasic.Collection>对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>